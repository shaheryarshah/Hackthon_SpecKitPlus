"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[630],{1897:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"vla-robotics/action-execution","title":"Action Execution Pipeline","description":"The action execution pipeline is the critical component that connects high-level plans generated by language models and reasoning systems to low-level robot controls. This pipeline ensures that abstract commands are translated into precise robotic actions while maintaining safety, handling failures, and adapting to environmental changes. The execution pipeline must be robust, responsive, and capable of real-time operation.","source":"@site/docs/06-vla-robotics/action-execution.md","sourceDirName":"06-vla-robotics","slug":"/vla-robotics/action-execution","permalink":"/docs/vla-robotics/action-execution","draft":false,"unlisted":false,"editUrl":"https://github.com/shaheryarshah/Hackthon_SpecKitPlus/edit/main/docs/docs/06-vla-robotics/action-execution.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"LLM-Based Planning for Robotics","permalink":"/docs/vla-robotics/llm-planning"},"next":{"title":"Capstone Project: Autonomous Humanoid Robot","permalink":"/docs/capstone/intro"}}');var o=t(4848),s=t(8453);const a={},r="Action Execution Pipeline",c={},l=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Hierarchical Action Execution",id:"hierarchical-action-execution",level:3},{value:"Action Representation",id:"action-representation",level:3},{value:"Real-Time Constraints",id:"real-time-constraints",level:3},{value:"Failure Detection and Recovery",id:"failure-detection-and-recovery",level:3},{value:"Equations and Models",id:"equations-and-models",level:2},{value:"Action Execution State Machine",id:"action-execution-state-machine",level:3},{value:"Action Execution Feedback Loop",id:"action-execution-feedback-loop",level:3},{value:"Safety Constraint Monitoring",id:"safety-constraint-monitoring",level:3},{value:"Code Example: Action Execution Pipeline",id:"code-example-action-execution-pipeline",level:2},{value:"Simulation Demonstration",id:"simulation-demonstration",level:2},{value:"Hands-On Lab: Action Execution Pipeline Implementation",id:"hands-on-lab-action-execution-pipeline-implementation",level:2},{value:"Required Equipment:",id:"required-equipment",level:3},{value:"Instructions:",id:"instructions",level:3},{value:"Common Pitfalls &amp; Debugging Notes",id:"common-pitfalls--debugging-notes",level:2},{value:"Summary &amp; Key Terms",id:"summary--key-terms",level:2},{value:"Further Reading &amp; Citations",id:"further-reading--citations",level:2},{value:"Assessment Questions",id:"assessment-questions",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"action-execution-pipeline",children:"Action Execution Pipeline"})}),"\n",(0,o.jsx)(n.p,{children:"The action execution pipeline is the critical component that connects high-level plans generated by language models and reasoning systems to low-level robot controls. This pipeline ensures that abstract commands are translated into precise robotic actions while maintaining safety, handling failures, and adapting to environmental changes. The execution pipeline must be robust, responsive, and capable of real-time operation."}),"\n",(0,o.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(n.p,{children:"After completing this section, you should be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Design action execution pipelines that bridge high-level planning and low-level controls"}),"\n",(0,o.jsx)(n.li,{children:"Implement safety checks and validation procedures for robotic actions"}),"\n",(0,o.jsx)(n.li,{children:"Handle action failures and recovery strategies"}),"\n",(0,o.jsx)(n.li,{children:"Monitor action execution and provide feedback to higher-level systems"}),"\n",(0,o.jsx)(n.li,{children:"Implement adaptive execution that responds to environmental changes"}),"\n",(0,o.jsx)(n.li,{children:"Design modular action execution systems that support different robot platforms"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,o.jsx)(n.h3,{id:"hierarchical-action-execution",children:"Hierarchical Action Execution"}),"\n",(0,o.jsx)(n.p,{children:"The action execution pipeline operates at different levels:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Task Level"}),": High-level goals and sub-goals"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Motion Planning Level"}),": Path planning and trajectory generation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Control Level"}),": Low-level motor commands and feedback control"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Actuator Level"}),": Direct commands to individual actuators"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"action-representation",children:"Action Representation"}),"\n",(0,o.jsx)(n.p,{children:"Actions in the pipeline can be represented as:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Symbolic Actions"}),": Abstract, high-level descriptions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Trajectory Actions"}),": Sequence of positions over time"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Force Actions"}),": Force/torque commands for compliant control"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Event-Driven Actions"}),": Actions triggered by sensor events"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"real-time-constraints",children:"Real-Time Constraints"}),"\n",(0,o.jsx)(n.p,{children:"The execution pipeline must operate under:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Hard Real-Time"}),": Safety-critical actions with strict timing requirements"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Soft Real-Time"}),": Performance-critical actions with preferred timing"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Best Effort"}),": Non-critical actions without strict timing requirements"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"failure-detection-and-recovery",children:"Failure Detection and Recovery"}),"\n",(0,o.jsx)(n.p,{children:"The pipeline must include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Anomaly Detection"}),": Identifying when actions are not proceeding as expected"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Graceful Degradation"}),": Continuing operation with reduced functionality"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Recovery Procedures"}),": Methods to return to safe states after failures"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Fallback Mechanisms"}),": Alternative strategies when primary methods fail"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"equations-and-models",children:"Equations and Models"}),"\n",(0,o.jsx)(n.h3,{id:"action-execution-state-machine",children:"Action Execution State Machine"}),"\n",(0,o.jsx)(n.p,{children:"The action execution process can be modeled as a state machine:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"States: {INIT, PREPARING, EXECUTING, MONITORING, PAUSED, RECOVERING, COMPLETED, FAILED}\nTransitions: \n- INIT \u2192 PREPARING: Action validation succeeds\n- PREPARING \u2192 EXECUTING: Pre-conditions met\n- EXECUTING \u2192 MONITORING: Motion initiated\n- MONITORING \u2192 COMPLETED: Success criteria met\n- MONITORING \u2192 FAILED: Failure criteria met\n- MONITORING \u2192 PAUSED: Pause requested\n- PAUSED \u2192 EXECUTING: Resume requested\n- FAILED \u2192 RECOVERING: Recovery procedure initiated\n- RECOVERING \u2192 COMPLETED: Recovery successful\n- RECOVERING \u2192 FAILED: Recovery unsuccessful\n"})}),"\n",(0,o.jsx)(n.h3,{id:"action-execution-feedback-loop",children:"Action Execution Feedback Loop"}),"\n",(0,o.jsx)(n.p,{children:"The control loop for action execution:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"\u03b5(t) = r(t) - y(t)\nu(t) = K_p * \u03b5(t) + K_i * \u222b\u03b5(t)dt + K_d * d\u03b5(t)/dt\n"})}),"\n",(0,o.jsx)(n.p,{children:"Where:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"\u03b5(t)"})," is the error at time t"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"r(t)"})," is the reference trajectory"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"y(t)"})," is the actual robot state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"u(t)"})," is the control command"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"K_p"}),", ",(0,o.jsx)(n.code,{children:"K_i"}),", ",(0,o.jsx)(n.code,{children:"K_d"})," are PID gains"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"safety-constraint-monitoring",children:"Safety Constraint Monitoring"}),"\n",(0,o.jsx)(n.p,{children:"Safety checks during execution:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"C_safe(x, u) \u2264 0\n"})}),"\n",(0,o.jsx)(n.p,{children:"Where:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"C_safe"})," represents safety constraints"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"x"})," is the robot state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"u"})," is the control input"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"code-example-action-execution-pipeline",children:"Code Example: Action Execution Pipeline"}),"\n",(0,o.jsx)(n.p,{children:"Here's an implementation of a comprehensive action execution pipeline:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport time\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Any, Optional, Callable\nimport threading\nimport queue\nfrom abc import ABC, abstractmethod\nimport numpy as np\n\n\nclass ActionStatus(Enum):\n    """Status of action execution"""\n    PENDING = "pending"\n    PREPARING = "preparing"\n    EXECUTING = "executing"\n    PAUSED = "paused"\n    COMPLETED = "completed"\n    FAILED = "failed"\n    CANCELLED = "cancelled"\n\n\nclass ActionType(Enum):\n    """Types of actions in the execution pipeline"""\n    NAVIGATE = "navigate"\n    GRASP = "grasp"\n    PLACE = "place"\n    MOVE_TO = "move_to"\n    ROTATE = "rotate"\n    DETECT = "detect"\n    FOLLOW = "follow"\n    WAIT = "wait"\n    CUSTOM = "custom"\n\n\n@dataclass\nclass Action:\n    """Represents a robotic action with execution parameters"""\n    action_type: ActionType\n    target_position: Optional[List[float]] = None\n    target_object: Optional[str] = None\n    target_location: Optional[str] = None\n    parameters: Optional[Dict[str, Any]] = None\n    priority: int = 5  # 1-10 priority level\n    timeout: float = 30.0  # seconds\n    preconditions: Optional[List[str]] = None\n    postconditions: Optional[List[str]] = None\n    description: Optional[str] = None\n\n\n@dataclass\nclass ExecutionResult:\n    """Result of action execution"""\n    action_id: str\n    status: ActionStatus\n    start_time: float\n    end_time: float\n    execution_time: float\n    error_message: Optional[str] = None\n    feedback_data: Optional[Dict[str, Any]] = None\n\n\nclass RobotControllerInterface(ABC):\n    """Abstract interface for robot controllers"""\n    \n    @abstractmethod\n    async def move_to(self, position: List[float], orientation: Optional[List[float]] = None) -> bool:\n        """Move robot to specific position"""\n        pass\n    \n    @abstractmethod\n    async def grasp(self, object_name: str) -> bool:\n        """Grasp an object"""\n        pass\n    \n    @abstractmethod\n    async def place(self, location: str) -> bool:\n        """Place object at location"""\n        pass\n    \n    @abstractmethod\n    async def rotate(self, angle: float) -> bool:\n        """Rotate robot"""\n        pass\n    \n    @abstractmethod\n    async def detect_object(self, object_name: str) -> Optional[Dict[str, Any]]:\n        """Detect and locate an object"""\n        pass\n    \n    @abstractmethod\n    async def follow_path(self, path: List[List[float]]) -> bool:\n        """Follow a path"""\n        pass\n    \n    @abstractmethod\n    async def stop_motion(self) -> bool:\n        """Emergency stop"""\n        pass\n    \n    @abstractmethod\n    async def get_robot_state(self) -> Dict[str, Any]:\n        """Get current robot state"""\n        pass\n\n\nclass MockRobotController(RobotControllerInterface):\n    """Mock robot controller for demonstration"""\n    \n    def __init__(self):\n        self.robot_position = [0.0, 0.0, 0.0]\n        self.gripper_state = "open"  # "open" or "closed"\n        self.is_moving = False\n        self.last_command_time = 0.0\n        self.simulation_speed = 1.0\n    \n    async def move_to(self, position: List[float], orientation: Optional[List[float]] = None) -> bool:\n        """Simulate moving to a position"""\n        if self.is_moving:\n            return False\n        \n        self.is_moving = True\n        self.last_command_time = time.time()\n        \n        # Simulate movement\n        start_pos = self.robot_position.copy()\n        distance = np.linalg.norm(np.array(position) - np.array(start_pos))\n        \n        # Simulate movement over time\n        steps = int(distance * 10)  # 10 steps per meter\n        for i in range(steps + 1):\n            progress = i / steps\n            self.robot_position = [\n                start_pos[0] + progress * (position[0] - start_pos[0]),\n                start_pos[1] + progress * (position[1] - start_pos[1]),\n                start_pos[2] + progress * (position[2] - start_pos[2])\n            ]\n            await asyncio.sleep(0.1 / self.simulation_speed)  # Simulate time to move\n        \n        self.robot_position = position.copy()\n        self.is_moving = False\n        \n        return True\n    \n    async def grasp(self, object_name: str) -> bool:\n        """Simulate grasping an object"""\n        if self.gripper_state == "closed":\n            return False  # Already grasping\n        \n        self.gripper_state = "closed"\n        self.last_command_time = time.time()\n        await asyncio.sleep(1.0 / self.simulation_speed)  # Simulate grasp time\n        \n        return True\n    \n    async def place(self, location: str) -> bool:\n        """Simulate placing an object"""\n        if self.gripper_state == "open":\n            return False  # Not grasping anything\n        \n        self.gripper_state = "open"\n        self.last_command_time = time.time()\n        await asyncio.sleep(1.0 / self.simulation_speed)  # Simulate place time\n        \n        return True\n    \n    async def rotate(self, angle: float) -> bool:\n        """Simulate rotating robot"""\n        self.last_command_time = time.time()\n        await asyncio.sleep(0.5 / self.simulation_speed)  # Simulate rotation time\n        \n        return True\n    \n    async def detect_object(self, object_name: str) -> Optional[Dict[str, Any]]:\n        """Simulate object detection"""\n        self.last_command_time = time.time()\n        await asyncio.sleep(0.5 / self.simulation_speed)  # Simulate detection time\n        \n        # Simulate successful detection\n        return {\n            "name": object_name,\n            "position": [np.random.uniform(0.5, 1.5), np.random.uniform(0.5, 1.5), 0.0],\n            "confidence": 0.9,\n            "detected": True\n        }\n    \n    async def follow_path(self, path: List[List[float]]) -> bool:\n        """Simulate following a path"""\n        if self.is_moving:\n            return False\n        \n        self.is_moving = True\n        self.last_command_time = time.time()\n        \n        for position in path:\n            await self.move_to(position)\n            await asyncio.sleep(0.1 / self.simulation_speed)\n        \n        self.is_moving = False\n        return True\n    \n    async def stop_motion(self) -> bool:\n        """Emergency stop"""\n        self.is_moving = False\n        return True\n    \n    async def get_robot_state(self) -> Dict[str, Any]:\n        """Get current robot state"""\n        return {\n            "position": self.robot_position,\n            "gripper_state": self.gripper_state,\n            "is_moving": self.is_moving,\n            "last_command_time": self.last_command_time\n        }\n\n\nclass SafetyMonitor:\n    """Monitors safety constraints during action execution"""\n    \n    def __init__(self):\n        self.safety_constraints = {\n            "collision_distance": 0.5,  # meters\n            "max_velocity": 1.0,  # m/s\n            "max_force": 100.0,  # Newtons\n            "joint_limits": [-3.14, 3.14],  # radians\n        }\n        self.emergency_stop_triggered = False\n        self.safety_violations = []\n    \n    def check_safety(self, robot_state: Dict[str, Any], requested_action: Action) -> bool:\n        """Check if action is safe to execute"""\n        # In a real implementation, this would check various safety metrics\n        # For this example, we\'ll just return True\n        if self.emergency_stop_triggered:\n            return False\n        \n        # Simulate checking safety constraints\n        is_safe = True\n        \n        # Example: check if target is too close to obstacles\n        if requested_action.target_position:\n            # This is a simplified check\n            pass\n        \n        return is_safe\n    \n    def trigger_emergency_stop(self):\n        """Trigger emergency stop"""\n        self.emergency_stop_triggered = True\n        print("EMERGENCY STOP TRIGGERED")\n    \n    def clear_emergency_stop(self):\n        """Clear emergency stop"""\n        self.emergency_stop_triggered = False\n        print("Emergency stop cleared")\n\n\nclass ActionExecutor:\n    """Executes individual actions with monitoring and safety"""\n    \n    def __init__(self, robot_controller: RobotControllerInterface, safety_monitor: SafetyMonitor):\n        self.robot_controller = robot_controller\n        self.safety_monitor = safety_monitor\n        self.current_action = None\n        self.action_id_counter = 0\n        self.execution_history = []\n    \n    async def execute_action(self, action: Action) -> ExecutionResult:\n        """Execute a single action with monitoring"""\n        action_id = f"action_{self.action_id_counter}"\n        self.action_id_counter += 1\n        \n        start_time = time.time()\n        result = ExecutionResult(\n            action_id=action_id,\n            status=ActionStatus.PENDING,\n            start_time=start_time,\n            end_time=0,\n            execution_time=0\n        )\n        \n        try:\n            # Check safety\n            robot_state = await self.robot_controller.get_robot_state()\n            if not self.safety_monitor.check_safety(robot_state, action):\n                result.status = ActionStatus.FAILED\n                result.error_message = "Safety check failed"\n                return result\n            \n            # Execute based on action type\n            success = await self._execute_action_type(action)\n            \n            if success:\n                result.status = ActionStatus.COMPLETED\n                result.feedback_data = await self._collect_feedback(action)\n            else:\n                result.status = ActionStatus.FAILED\n                result.error_message = f"Action execution failed for {action.action_type}"\n        \n        except asyncio.CancelledError:\n            result.status = ActionStatus.CANCELLED\n            result.error_message = "Action was cancelled"\n        except Exception as e:\n            result.status = ActionStatus.FAILED\n            result.error_message = f"Exception during execution: {str(e)}"\n        finally:\n            result.end_time = time.time()\n            result.execution_time = result.end_time - result.start_time\n            self.execution_history.append(result)\n        \n        return result\n    \n    async def _execute_action_type(self, action: Action) -> bool:\n        """Execute action based on its type"""\n        if action.action_type == ActionType.NAVIGATE:\n            if action.target_position:\n                return await self.robot_controller.move_to(action.target_position)\n        elif action.action_type == ActionType.GRASP:\n            if action.target_object:\n                return await self.robot_controller.grasp(action.target_object)\n        elif action.action_type == ActionType.PLACE:\n            if action.target_location:\n                return await self.robot_controller.place(action.target_location)\n        elif action.action_type == ActionType.MOVE_TO:\n            if action.target_position:\n                return await self.robot_controller.move_to(action.target_position)\n        elif action.action_type == ActionType.ROTATE:\n            if action.parameters and "angle" in action.parameters:\n                return await self.robot_controller.rotate(action.parameters["angle"])\n        elif action.action_type == ActionType.DETECT:\n            if action.target_object:\n                result = await self.robot_controller.detect_object(action.target_object)\n                return result is not None and result.get("detected", False)\n        elif action.action_type == ActionType.FOLLOW:\n            if action.parameters and "path" in action.parameters:\n                return await self.robot_controller.follow_path(action.parameters["path"])\n        elif action.action_type == ActionType.WAIT:\n            wait_time = action.parameters.get("duration", 1.0) if action.parameters else 1.0\n            await asyncio.sleep(wait_time)\n            return True\n        \n        return False  # Unknown action type or missing parameters\n    \n    async def _collect_feedback(self, action: Action) -> Dict[str, Any]:\n        """Collect feedback after action execution"""\n        robot_state = await self.robot_controller.get_robot_state()\n        return {\n            "robot_state": robot_state,\n            "action_completed": action.action_type.value,\n            "timestamp": time.time()\n        }\n\n\nclass ExecutionPipeline:\n    """Main execution pipeline that manages action execution"""\n    \n    def __init__(self, robot_controller: RobotControllerInterface):\n        self.robot_controller = robot_controller\n        self.safety_monitor = SafetyMonitor()\n        self.action_executor = ActionExecutor(robot_controller, self.safety_monitor)\n        self.action_queue = queue.Queue()\n        self.is_running = False\n        self.execution_thread = None\n        self.current_execution_task = None\n        self.cancellation_token = None\n    \n    def start_pipeline(self):\n        """Start the execution pipeline"""\n        if self.is_running:\n            return\n        \n        self.is_running = True\n        self.execution_thread = threading.Thread(target=self._pipeline_worker)\n        self.execution_thread.start()\n        print("Execution pipeline started")\n    \n    def stop_pipeline(self):\n        """Stop the execution pipeline"""\n        self.is_running = False\n        if self.current_execution_task:\n            self.current_execution_task.cancel()\n        if self.execution_thread:\n            self.execution_thread.join()\n        print("Execution pipeline stopped")\n    \n    def _pipeline_worker(self):\n        """Worker function for the execution pipeline"""\n        while self.is_running:\n            try:\n                # Check for actions in queue\n                if not self.action_queue.empty():\n                    action = self.action_queue.get(timeout=0.1)\n                    asyncio.run(self._execute_single_action(action))\n                else:\n                    time.sleep(0.01)  # Small delay to prevent busy waiting\n            except queue.Empty:\n                continue\n            except Exception as e:\n                print(f"Pipeline worker error: {e}")\n    \n    async def _execute_single_action(self, action: Action):\n        """Execute a single action asynchronously"""\n        if self.current_execution_task:\n            # Cancel any currently running action if needed\n            self.current_execution_task.cancel()\n        \n        # Create and run the execution task\n        self.current_execution_task = asyncio.create_task(self.action_executor.execute_action(action))\n        try:\n            result = await self.current_execution_task\n            print(f"Action {result.action_id} completed with status: {result.status}")\n        except asyncio.CancelledError:\n            print("Action execution was cancelled")\n    \n    def submit_action(self, action: Action) -> str:\n        """Submit an action for execution"""\n        if not self.is_running:\n            raise RuntimeError("Execution pipeline is not running")\n        \n        self.action_queue.put(action)\n        return f"submitted_action_{self.action_executor.action_id_counter}"\n    \n    def submit_action_sequence(self, actions: List[Action]) -> str:\n        """Submit a sequence of actions for execution"""\n        sequence_id = f"sequence_{int(time.time())}"\n        \n        async def execute_sequence():\n            for i, action in enumerate(actions):\n                print(f"Executing action {i+1}/{len(actions)}: {action.action_type.value}")\n                result = await self.action_executor.execute_action(action)\n                if result.status != ActionStatus.COMPLETED:\n                    print(f"Action sequence failed at step {i+1}")\n                    return sequence_id\n            print(f"Action sequence {sequence_id} completed successfully")\n            return sequence_id\n        \n        # In a real implementation, this would run the sequence task\n        # For this example, we\'ll add each action to the queue\n        for action in actions:\n            self.submit_action(action)\n        \n        return sequence_id\n    \n    def get_status(self) -> Dict[str, Any]:\n        """Get current status of the execution pipeline"""\n        return {\n            "is_running": self.is_running,\n            "queue_size": self.action_queue.qsize(),\n            "executed_actions": len(self.action_executor.execution_history),\n            "safety_monitor_status": {\n                "emergency_stop": self.safety_monitor.emergency_stop_triggered,\n                "violations_count": len(self.safety_monitor.safety_violations)\n            }\n        }\n\n\ndef main():\n    """Example usage of the action execution pipeline"""\n    print("Action Execution Pipeline Example")\n    \n    # Initialize the robot controller and execution pipeline\n    robot_controller = MockRobotController()\n    execution_pipeline = ExecutionPipeline(robot_controller)\n    \n    # Start the pipeline\n    execution_pipeline.start_pipeline()\n    \n    # Create test actions\n    test_actions = [\n        Action(\n            action_type=ActionType.MOVE_TO,\n            target_position=[1.0, 0.0, 0.0],\n            description="Move to position 1"\n        ),\n        Action(\n            action_type=ActionType.GRASP,\n            target_object="red_cup",\n            description="Grasp the red cup"\n        ),\n        Action(\n            action_type=ActionType.MOVE_TO,\n            target_position=[0.0, 1.0, 0.0],\n            description="Move to position 2"\n        ),\n        Action(\n            action_type=ActionType.PLACE,\n            target_location="table",\n            description="Place object on table"\n        )\n    ]\n    \n    print(f"Submitting {len(test_actions)} test actions...")\n    \n    # Submit actions to pipeline\n    action_ids = []\n    for i, action in enumerate(test_actions):\n        action_id = execution_pipeline.submit_action(action)\n        action_ids.append(action_id)\n        print(f"Submitted action {i+1}: {action_id}")\n        time.sleep(0.5)  # Add small delay between submissions\n    \n    # Wait a bit for execution\n    time.sleep(8)\n    \n    # Submit a sequence of actions\n    sequence_actions = [\n        Action(\n            action_type=ActionType.ROTATE,\n            parameters={"angle": 1.57},  # 90 degrees\n            description="Rotate 90 degrees"\n        ),\n        Action(\n            action_type=ActionType.DETECT,\n            target_object="box",\n            description="Detect box"\n        )\n    ]\n    \n    print("\\nSubmitting action sequence...")\n    sequence_id = execution_pipeline.submit_action_sequence(sequence_actions)\n    print(f"Submitted sequence: {sequence_id}")\n    \n    # Wait for sequence execution\n    time.sleep(5)\n    \n    # Get pipeline status\n    status = execution_pipeline.get_status()\n    print(f"\\nPipeline status: {status}")\n    \n    # Stop the pipeline\n    execution_pipeline.stop_pipeline()\n    \n    print("\\nAction execution pipeline example completed")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"simulation-demonstration",children:"Simulation Demonstration"}),"\n",(0,o.jsx)(n.p,{children:"This implementation demonstrates a comprehensive action execution pipeline that bridges high-level plans to low-level robot controls. The system includes safety monitoring, failure handling, and real-time execution capabilities. The code can be integrated with ROS 2 and simulation environments to create robust robotic action execution systems."}),"\n",(0,o.jsx)(n.h2,{id:"hands-on-lab-action-execution-pipeline-implementation",children:"Hands-On Lab: Action Execution Pipeline Implementation"}),"\n",(0,o.jsx)(n.p,{children:"In this lab, you'll implement and test a complete action execution pipeline:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Implement the action execution pipeline with safety monitoring"}),"\n",(0,o.jsx)(n.li,{children:"Create action representations and execution handlers"}),"\n",(0,o.jsx)(n.li,{children:"Test with different action types and sequences"}),"\n",(0,o.jsx)(n.li,{children:"Implement failure detection and recovery procedures"}),"\n",(0,o.jsx)(n.li,{children:"Evaluate pipeline performance and safety"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"required-equipment",children:"Required Equipment:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"ROS 2 Humble environment"}),"\n",(0,o.jsx)(n.li,{children:"Robot simulation environment (e.g., Gazebo, Isaac Sim)"}),"\n",(0,o.jsx)(n.li,{children:"Python development environment"}),"\n",(0,o.jsx)(n.li,{children:"(Optional) Physical robot for testing"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"instructions",children:"Instructions:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Create a new ROS 2 package: ",(0,o.jsx)(n.code,{children:"ros2 pkg create --build-type ament_python action_execution_pipeline"})]}),"\n",(0,o.jsx)(n.li,{children:"Implement the ActionExecutor and ExecutionPipeline classes"}),"\n",(0,o.jsx)(n.li,{children:"Create action representations for different robot capabilities"}),"\n",(0,o.jsx)(n.li,{children:"Implement safety monitoring and emergency stop procedures"}),"\n",(0,o.jsx)(n.li,{children:"Test with various action sequences in simulation"}),"\n",(0,o.jsx)(n.li,{children:"Add failure injection to test recovery mechanisms"}),"\n",(0,o.jsx)(n.li,{children:"Evaluate performance metrics (latency, success rate, etc.)"}),"\n",(0,o.jsx)(n.li,{children:"Document the system's capabilities and limitations"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"common-pitfalls--debugging-notes",children:"Common Pitfalls & Debugging Notes"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Race Conditions"}),": Multiple threads accessing shared resources without proper synchronization"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Timeout Handling"}),": Actions that don't complete within expected timeframes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"State Synchronization"}),": Ensuring the execution system has accurate robot state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Safety Checks"}),": Missing or insufficient safety validations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resource Management"}),": Proper cleanup of resources during execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Error Propagation"}),": Errors in one action affecting subsequent actions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Timing Constraints"}),": Missing real-time deadlines for critical actions"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary--key-terms",children:"Summary & Key Terms"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Key Terms:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action Execution Pipeline"}),": System connecting high-level plans to low-level controls"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action Representation"}),": Formal description of robotic actions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Safety Monitor"}),": System checking for safety constraints during execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Failure Recovery"}),": Procedures to handle and recover from action failures"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-Time Execution"}),": Meeting timing constraints for robotic actions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Action Sequencing"}),": Executing multiple actions in proper order"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"State Feedback"}),": Monitoring robot state during action execution"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"further-reading--citations",children:"Further Reading & Citations"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:'Fox, D., et al. (1997). "The dynamic window approach to collision avoidance." IEEE Robotics & Automation Magazine.'}),"\n",(0,o.jsx)(n.li,{children:'Khatib, O. (1986). "Real-time obstacle avoidance for manipulators and mobile robots." International Journal of Robotics Research.'}),"\n",(0,o.jsx)(n.li,{children:'Siciliano, B., & Khatib, O. (Eds.). (2016). "Springer Handbook of Robotics." Springer.'}),"\n",(0,o.jsx)(n.li,{children:'Alami, R., et al. (2006). "A tightly integrated execution system for mobile manipulation tasks." IEEE/RSJ International Conference on Intelligent Robots and Systems.'}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Explain the role of the action execution pipeline in connecting high-level planning to low-level controls."}),"\n",(0,o.jsx)(n.li,{children:"What are the key safety considerations in action execution for robotics?"}),"\n",(0,o.jsx)(n.li,{children:"Describe the state machine model for action execution and its states."}),"\n",(0,o.jsx)(n.li,{children:"How can failure detection and recovery be implemented in action execution pipelines?"}),"\n",(0,o.jsx)(n.li,{children:"What real-time constraints must be considered when designing action execution systems?"}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Previous"}),": ",(0,o.jsx)(n.a,{href:"/docs/vla-robotics/llm-planning",children:"LLM-Based Planning for Robotics"}),(0,o.jsx)(n.br,{}),"\n",(0,o.jsx)(n.strong,{children:"Next"}),": ",(0,o.jsx)(n.a,{href:"../../07-capstone/intro.md",children:"Introduction to Humanoid Robotics"})]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);