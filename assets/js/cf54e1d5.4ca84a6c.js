"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[736],{4824:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"humanoid-robotics/manipulation","title":"Manipulation & Humanoid Hands","description":"Manipulation is a fundamental capability that gives humanoid robots the ability to interact with their environment by grasping, manipulating, and releasing objects. This section explores the specialized challenges of dexterous manipulation for humanoid robots, including the biomechanics of human-like hands, grasp planning, and control strategies for performing complex manipulation tasks.","source":"@site/docs/05-humanoid-robotics/manipulation.md","sourceDirName":"05-humanoid-robotics","slug":"/humanoid-robotics/manipulation","permalink":"/docs/humanoid-robotics/manipulation","draft":false,"unlisted":false,"editUrl":"https://github.com/shaheryarshah/Hackthon_SpecKitPlus/edit/main/docs/docs/05-humanoid-robotics/manipulation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Bipedal Locomotion and Walking Control","permalink":"/docs/humanoid-robotics/locomotion"},"next":{"title":"Human-Robot Interaction (HRI)","permalink":"/docs/humanoid-robotics/hri"}}');var s=i(4848),o=i(8453);const a={},r="Manipulation & Humanoid Hands",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Hand Biomechanics",id:"hand-biomechanics",level:3},{value:"Grasp Types",id:"grasp-types",level:3},{value:"Grasp Planning",id:"grasp-planning",level:3},{value:"Control Strategies",id:"control-strategies",level:3},{value:"Equations and Models",id:"equations-and-models",level:2},{value:"Grasp Quality Measures",id:"grasp-quality-measures",level:3},{value:"Grasp Stability Metric",id:"grasp-stability-metric",level:3},{value:"Multi-Finger Coordination",id:"multi-finger-coordination",level:3},{value:"Impedance Control",id:"impedance-control",level:3},{value:"Code Example: Humanoid Manipulation Controller",id:"code-example-humanoid-manipulation-controller",level:2},{value:"Simulation Demonstration",id:"simulation-demonstration",level:2},{value:"Hands-On Lab: Humanoid Manipulation Implementation",id:"hands-on-lab-humanoid-manipulation-implementation",level:2},{value:"Required Equipment:",id:"required-equipment",level:3},{value:"Instructions:",id:"instructions",level:3},{value:"Common Pitfalls &amp; Debugging Notes",id:"common-pitfalls--debugging-notes",level:2},{value:"Summary &amp; Key Terms",id:"summary--key-terms",level:2},{value:"Further Reading &amp; Citations",id:"further-reading--citations",level:2},{value:"Assessment Questions",id:"assessment-questions",level:2}];function p(n){const e={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"manipulation--humanoid-hands",children:"Manipulation & Humanoid Hands"})}),"\n",(0,s.jsx)(e.p,{children:"Manipulation is a fundamental capability that gives humanoid robots the ability to interact with their environment by grasping, manipulating, and releasing objects. This section explores the specialized challenges of dexterous manipulation for humanoid robots, including the biomechanics of human-like hands, grasp planning, and control strategies for performing complex manipulation tasks."}),"\n",(0,s.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,s.jsx)(e.p,{children:"After completing this section, you should be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand the biomechanics and design principles of humanoid hands"}),"\n",(0,s.jsx)(e.li,{children:"Implement grasp planning algorithms for various object types"}),"\n",(0,s.jsx)(e.li,{children:"Design control strategies for dexterous manipulation"}),"\n",(0,s.jsx)(e.li,{children:"Create synergistic control approaches for multi-fingered hands"}),"\n",(0,s.jsx)(e.li,{children:"Implement force and tactile feedback methods for manipulation"}),"\n",(0,s.jsx)(e.li,{children:"Evaluate the manipulation capabilities of humanoid robots"}),"\n",(0,s.jsx)(e.li,{children:"Address challenges specific to humanoid manipulation such as dexterity and force control"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(e.h3,{id:"hand-biomechanics",children:"Hand Biomechanics"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid hands must replicate the complex biomechanics of human hands:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Degrees of Freedom"}),": Each finger has multiple joints allowing for complex movements"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Opposable Thumb"}),": Essential for precision grasps and tool use"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Muscle Synergies"}),": Coordinated activation of multiple muscles to achieve specific functions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tactile Sensing"}),": Distributed sensing for grip force, texture, and slip detection"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"grasp-types",children:"Grasp Types"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robots need to implement multiple grasp types:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Power Grasps"}),": Strong, stable grasps using palm and fingers for lifting heavy objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Precision Grasps"}),": Delicate grasps using fingertips for fine control tasks"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Pinch Grasps"}),": Grasps between thumb and another finger for small objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Specialized Grasps"}),": Tool-specific or object-specific grasps"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"grasp-planning",children:"Grasp Planning"}),"\n",(0,s.jsx)(e.p,{children:"Effective manipulation requires intelligent grasp planning:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Geometry Analysis"}),": Understanding object shape, size, and surface properties"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stability Optimization"}),": Planning grasps that provide stable object holding"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force Optimization"}),": Distributing forces across contact points appropriately"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Accessibility Planning"}),": Ensuring the robot can physically reach and grasp the target"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"control-strategies",children:"Control Strategies"}),"\n",(0,s.jsx)(e.p,{children:"Precise manipulation requires advanced control approaches:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Impedance Control"}),": Controlling the mechanical impedance of the hand"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Hybrid Position/Force Control"}),": Controlling both position and forces simultaneously"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Adaptive Control"}),": Adjusting control parameters based on environmental conditions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Learning-based Control"}),": Using experiences to improve future manipulation"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"equations-and-models",children:"Equations and Models"}),"\n",(0,s.jsx)(e.h3,{id:"grasp-quality-measures",children:"Grasp Quality Measures"}),"\n",(0,s.jsx)(e.p,{children:"The grasp quality can be measured using the grasp matrix:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"G = [n\u2081  n\u2082  ...  n\u2096]\n    [r\u2081\xd7n\u2081  r\u2082\xd7n\u2082  ...  r\u2096\xd7n\u2096]\n"})}),"\n",(0,s.jsx)(e.p,{children:"Where:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"n\u1d62"})," is the normal vector at contact point i"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"r\u1d62"})," is the position vector from object center to contact point i"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"k"})," is the number of contact points"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"A grasp is force-closure if the convex hull of the contact wrenches contains the origin."}),"\n",(0,s.jsx)(e.h3,{id:"grasp-stability-metric",children:"Grasp Stability Metric"}),"\n",(0,s.jsx)(e.p,{children:"A measure of grasp stability:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"S = (\u03bc\u2081 * f\u2081 + \u03bc\u2082 * f\u2082 + ... + \u03bc\u2096 * f\u2096) / W\n"})}),"\n",(0,s.jsx)(e.p,{children:"Where:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"\u03bc\u1d62"})," is the coefficient of friction at contact point i"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"f\u1d62"})," is the normal force at contact point i"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"W"})," is the weight of the object"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"k"})," is the number of contact points"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"multi-finger-coordination",children:"Multi-Finger Coordination"}),"\n",(0,s.jsx)(e.p,{children:"The synergy between fingers can be expressed as:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"\u03b8 = J \xb7 s\n"})}),"\n",(0,s.jsx)(e.p,{children:"Where:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"\u03b8"})," is the vector of joint angles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"J"})," is the synergy Jacobian matrix"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"s"})," is the synergy vector (activation levels)"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,s.jsx)(e.p,{children:"The relationship between forces, positions, and accelerations in impedance control:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"M(q)q\u0308 + C(q,q\u0307)q\u0307 + G(q) = \u03c4 + J\u1d40F_ext\n"})}),"\n",(0,s.jsx)(e.p,{children:"Where:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"M(q)"})," is the mass matrix"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"C(q,q\u0307)"})," are Coriolis and centrifugal forces"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"G(q)"})," is gravitational forces"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"\u03c4"})," is control torques"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"J"})," is the Jacobian matrix"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"F_ext"})," is external forces"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"code-example-humanoid-manipulation-controller",children:"Code Example: Humanoid Manipulation Controller"}),"\n",(0,s.jsx)(e.p,{children:"Here's an implementation of a manipulation controller for humanoid robots:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport math\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional, Tuple\nfrom enum import Enum\nimport asyncio\n\n\nclass GraspType(Enum):\n    """Types of grasps for humanoid manipulation"""\n    POWER_GRASP = "power_grasp"\n    PINCH_GRASP = "pinch_grasp"\n    PRECISION_GRASP = "precision_grasp"\n    LATERAL_PINCH = "lateral_pinch"\n    SPHERICAL_GRASP = "spherical_grasp"\n    CYLINDRICAL_GRASP = "cylindrical_grasp"\n\n\nclass Finger(Enum):\n    """Finger identifiers for humanoid hands"""\n    THUMB = "thumb"\n    INDEX = "index"\n    MIDDLE = "middle"\n    RING = "ring"\n    PINKY = "pinky"\n\n\n@dataclass\nclass ObjectProperties:\n    """Properties of objects for manipulation planning"""\n    shape: str  # \'cylinder\', \'sphere\', \'box\', \'complex\'\n    dimensions: List[float]  # [length, width, height] or radius\n    weight: float  # in kg\n    center_of_mass: List[float]  # [x, y, z] relative to object center\n    friction_coeff: float  # Coefficient of friction\n    material: str  # \'plastic\', \'metal\', \'paper\', etc.\n    fragility: float  # 0-1 scale, 1 = very fragile\n\n\n@dataclass\nclass GraspConfiguration:\n    """Configuration for a specific grasp"""\n    grasp_type: GraspType\n    contact_points: List[Tuple[float, float, float]]  # (x, y, z) positions\n    contact_forces: List[float]  # Force magnitudes at each contact\n    finger_positions: Dict[Finger, List[float]]  # Joint positions for each finger\n    stability_score: float  # 0-1 scale\n    force_closure: bool  # Whether the grasp achieves force closure\n\n\nclass HandKinematics:\n    """Model for humanoid hand kinematics and grasp planning"""\n    \n    def __init__(self, hand_type="human_like"):\n        """\n        Initialize hand kinematics model\n        \n        :param hand_type: Type of hand model (\'human_like\', \'robotic\', etc.)\n        """\n        self.hand_type = hand_type\n        self.finger_count = 5  # thumb + 4 fingers\n        self.joints_per_finger = 4  # simplified model\n        self.finger_lengths = {  # in meters\n            Finger.THUMB: 0.04,\n            Finger.INDEX: 0.07,\n            Finger.MIDDLE: 0.08,\n            Finger.RING: 0.07,\n            Finger.PINKY: 0.06\n        }\n        \n        # Initialize finger angles (rest position)\n        self.finger_angles = {\n            Finger.THUMB: [0.0, 0.0, 0.0, 0.0],\n            Finger.INDEX: [0.0, 0.0, 0.0, 0.0],\n            Finger.MIDDLE: [0.0, 0.0, 0.0, 0.0],\n            Finger.RING: [0.0, 0.0, 0.0, 0.0],\n            Finger.PINKY: [0.0, 0.0, 0.0, 0.0]\n        }\n    \n    def forward_kinematics(self, finger: Finger, joint_angles: List[float]) -> List[float]:\n        """\n        Calculate fingertip position from joint angles (simplified 2D model)\n        \n        :param finger: Finger to calculate for\n        :param joint_angles: List of joint angles in radians\n        :return: Fingertip position [x, y, z]\n        """\n        # Simplified forward kinematics for demonstration\n        # In a real implementation, this would be more complex with full 3D kinematics\n        \n        # Start from palm position (assumed at [0, 0, 0])\n        x, y, z = 0.0, 0.0, 0.0\n        \n        # Calculate cumulative position through joints\n        segment_length = self.finger_lengths[finger] / len(joint_angles)\n        \n        for i, angle in enumerate(joint_angles):\n            # Project the segment in the direction of accumulated angles\n            segment_x = segment_length * math.cos(sum(joint_angles[:i+1]))\n            segment_y = segment_length * math.sin(sum(joint_angles[:i+1]))\n            \n            x += segment_x\n            y += segment_y\n            # For simplicity, z stays at 0 (would be 3D in real implementation)\n        \n        return [x, y, z]\n    \n    def inverse_kinematics(self, finger: Finger, target_pos: List[float]) -> Optional[List[float]]:\n        """\n        Calculate joint angles to reach target position (simplified)\n        \n        :param finger: Finger to calculate for\n        :param target_pos: Target position [x, y, z]\n        :return: Joint angles or None if unreachable\n        """\n        # Simplified inverse kinematics for demonstration\n        # In a real implementation, this would use more sophisticated algorithms\n        \n        # Calculate distance to target\n        dist = math.sqrt(target_pos[0]**2 + target_pos[1]**2 + target_pos[2]**2)\n        \n        # Check if target is reachable\n        max_reach = sum([self.finger_lengths[finger] for finger in Finger]) / 5\n        if dist > max_reach:\n            return None\n        \n        # Use geometric approach for simplified 2-link model\n        # For real implementation, would use more complex methods\n        \n        # Calculate required angles (simplified)\n        angle_1 = math.atan2(target_pos[1], target_pos[0])\n        remaining_dist = max(0, dist - self.finger_lengths[finger]/2)\n        \n        # For simplicity, distribute remaining motion equally among joints\n        remaining_angle = math.asin(remaining_dist / (self.finger_lengths[finger]/2))\n        \n        return [angle_1 / 2, remaining_angle / 2, remaining_angle / 2, remaining_angle / 2]\n\n\nclass GraspPlanner:\n    """Planning grasps for humanoids based on object properties"""\n    \n    def __init__(self):\n        self.hand_model = HandKinematics()\n        self.stability_threshold = 0.7\n        self.force_closure_threshold = 0.8\n    \n    def plan_grasp(self, obj_props: ObjectProperties, current_hand_pose: List[float]) -> Optional[GraspConfiguration]:\n        """\n        Plan an appropriate grasp for the given object\n        \n        :param obj_props: Properties of the object to grasp\n        :param current_hand_pose: Current position/orientation of the hand\n        :return: Grasp configuration or None if no suitable grasp found\n        """\n        # Determine appropriate grasp type based on object properties\n        grasp_type = self._select_grasp_type(obj_props)\n        \n        # Plan contact points based on object geometry\n        contact_points = self._plan_contact_points(obj_props, grasp_type)\n        \n        # Calculate required contact forces\n        contact_forces = self._calculate_contact_forces(obj_props, contact_points)\n        \n        # Determine finger positions\n        finger_positions = self._plan_finger_positions(contact_points, grasp_type)\n        \n        # Evaluate grasp stability\n        stability_score = self._evaluate_stability(\n            contact_points, \n            contact_forces, \n            obj_props.friction_coeff\n        )\n        \n        force_closure = self._check_force_closure(contact_points)\n        \n        if stability_score < self.stability_threshold:\n            # Try alternative grasp types\n            for alt_type in self._get_alternative_grasps(grasp_type):\n                alt_config = self._plan_specific_grasp(obj_props, alt_type, current_hand_pose)\n                if alt_config and alt_config.stability_score > stability_score:\n                    return alt_config\n        \n        return GraspConfiguration(\n            grasp_type=grasp_type,\n            contact_points=contact_points,\n            contact_forces=contact_forces,\n            finger_positions=finger_positions,\n            stability_score=stability_score,\n            force_closure=force_closure\n        )\n    \n    def _select_grasp_type(self, obj_props: ObjectProperties) -> GraspType:\n        """Select appropriate grasp type based on object properties"""\n        if obj_props.shape == \'sphere\' and obj_props.dimensions[0] < 0.05:  # Small sphere\n            return GraspType.PINCH_GRASP\n        elif obj_props.shape == \'cylinder\' and obj_props.dimensions[0] < 0.03:  # Small cylinder\n            return GraspType.PRECISION_GRASP\n        elif obj_props.weight > 1.0:  # Heavy object\n            return GraspType.POWER_GRASP\n        elif obj_props.dimensions[0] > 0.1:  # Large object\n            return GraspType.SPHERICAL_GRASP\n        else:\n            return GraspType.PINCH_GRASP  # Default\n    \n    def _plan_contact_points(self, obj_props: ObjectProperties, grasp_type: GraspType) -> List[Tuple[float, float, float]]:\n        """Plan contact points based on object geometry and grasp type"""\n        contacts = []\n        \n        if obj_props.shape == \'sphere\':\n            radius = obj_props.dimensions[0]\n            if grasp_type == GraspType.PINCH_GRASP:\n                # Two contact points for pinch grasp\n                contacts.extend([\n                    (radius, 0.0, 0.0),   # Right side\n                    (-radius, 0.0, 0.0)   # Left side\n                ])\n            elif grasp_type == GraspType.POWER_GRASP:\n                # Multiple contact points around the sphere\n                for i in range(6):  # 6 contact points\n                    angle = 2 * math.pi * i / 6\n                    x = radius * math.cos(angle)\n                    y = radius * math.sin(angle)\n                    contacts.append((x, y, 0.0))\n        \n        elif obj_props.shape == \'cylinder\':\n            radius, height = obj_props.dimensions[0], obj_props.dimensions[1]\n            if grasp_type == GraspType.PINCH_GRASP:\n                contacts.extend([\n                    (radius, 0.0, height/2),   # Top-right\n                    (-radius, 0.0, height/2)   # Top-left\n                ])\n            elif grasp_type == GraspType.CYLINDRICAL_GRASP:\n                # Wrap-around grasp with 4 contact points\n                for i in range(4):\n                    angle = math.pi * i / 2\n                    x = radius * math.cos(angle)\n                    y = radius * math.sin(angle)\n                    contacts.append((x, y, 0.0))\n        \n        elif obj_props.shape == \'box\':\n            length, width, height = obj_props.dimensions\n            if grasp_type in [GraspType.PINCH_GRASP, GraspType.PRECISION_GRASP]:\n                # Grasp on the top face\n                contacts.extend([\n                    (length/2, width/2, height/2),    # Top-right corner\n                    (-length/2, width/2, height/2)    # Top-left corner\n                ])\n        \n        return contacts[:8]  # Limit to maximum 8 contacts for computational efficiency\n    \n    def _calculate_contact_forces(self, obj_props: ObjectProperties, contact_points: List[Tuple[float, float, float]]) -> List[float]:\n        """Calculate required contact forces to stably grasp the object"""\n        # Calculate total weight\n        weight = obj_props.weight * 9.81  # Weight in Newtons\n        \n        # Distribute force among contact points\n        num_contacts = len(contact_points)\n        base_force = weight / num_contacts if num_contacts > 0 else 0\n        \n        # Add safety factor\n        safety_factor = 1.5\n        forces = [base_force * safety_factor for _ in contact_points]\n        \n        # Adjust for object fragility\n        fragility_factor = 1.0 / (1 + obj_props.fragility * 2)  # More fragile = less force\n        forces = [f * fragility_factor for f in forces]\n        \n        return forces\n    \n    def _plan_finger_positions(self, contact_points: List[Tuple[float, float, float]], grasp_type: GraspType) -> Dict[Finger, List[float]]:\n        """Plan finger positions for the grasp"""\n        finger_positions = {}\n        \n        if grasp_type == GraspType.PINCH_GRASP:\n            # Thumb and index finger grasp\n            if len(contact_points) >= 2:\n                # Position thumb and index finger at contact points\n                thumb_target = contact_points[0]\n                index_target = contact_points[1]\n                \n                # Calculate required joint angles (this is highly simplified)\n                thumb_angles = [0.0, 0.8, 0.5, 0.3]  # Example joint angles\n                index_angles = [0.0, 0.6, 0.4, 0.2]\n                \n                finger_positions[Finger.THUMB] = thumb_angles\n                finger_positions[Finger.INDEX] = index_angles\n                \n                # Other fingers stay in rest position\n                for finger in [Finger.MIDDLE, Finger.RING, Finger.PINKY]:\n                    finger_positions[finger] = [0.0, 0.0, 0.0, 0.0]\n        \n        elif grasp_type == GraspType.POWER_GRASP:\n            # Wraparound grasp - all fingers involved\n            for finger in Finger:\n                # Example: all fingers wrapped around the object\n                finger_positions[finger] = [0.2, 0.7, 0.6, 0.4]\n        \n        elif grasp_type == GraspType.PRECISION_GRASP:\n            # Precision grasp with multiple fingertips\n            if len(contact_points) >= 3:\n                # Thumb, index, and middle finger tips\n                for i, finger in enumerate([Finger.THUMB, Finger.INDEX, Finger.MIDDLE]):\n                    # Example angles for precision grasp\n                    finger_positions[finger] = [0.0, 0.9, 0.7, 0.5]\n                \n                # Ring and pinky fingers in stabilizing position\n                finger_positions[Finger.RING] = [0.0, 0.3, 0.2, 0.1]\n                finger_positions[Finger.PINKY] = [0.0, 0.3, 0.2, 0.1]\n        \n        return finger_positions\n    \n    def _evaluate_stability(self, contact_points: List[Tuple[float, float, float]], contact_forces: List[float], friction_coeff: float) -> float:\n        """Evaluate the stability of the planned grasp"""\n        if len(contact_points) < 2 or len(contact_forces) < 2:\n            return 0.0\n        \n        # Simplified stability calculation based on force distribution\n        # In a real implementation, this would use more complex grasp analysis\n        \n        # Calculate average force per contact\n        avg_force = sum(contact_forces) / len(contact_forces) if contact_forces else 0\n        \n        # Calculate variance in forces (more uniform = more stable)\n        force_variance = sum([(f - avg_force)**2 for f in contact_forces]) / len(contact_forces) if contact_forces else 0\n        \n        # Stability score is inversely proportional to variance (and normalized)\n        max_variance = 10.0  # Example maximum expected variance\n        stability_score = max(0.0, 1.0 - (force_variance / max_variance))\n        \n        # Also consider friction and geometric factors\n        friction_factor = min(1.0, 0.5 + friction_coeff * 0.5)  # Friction contributes to stability\n        \n        final_score = (stability_score + friction_factor) / 2\n        \n        return final_score\n    \n    def _check_force_closure(self, contact_points: List[Tuple[float, float, float]]) -> bool:\n        """Check if the grasp achieves force closure"""\n        # Simplified force closure check\n        # In a real implementation, this would use more rigorous mathematical checks\n        return len(contact_points) >= 3\n    \n    def _get_alternative_grasps(self, primary_grasp: GraspType) -> List[GraspType]:\n        """Get alternative grasp types to try if primary fails"""\n        alternatives = {\n            GraspType.PINCH_GRASP: [GraspType.POWER_GRASP, GraspType.PRECISION_GRASP],\n            GraspType.POWER_GRASP: [GraspType.PINCH_GRASP, GraspType.CYLINDRICAL_GRASP],\n            GraspType.PRECISION_GRASP: [GraspType.PINCH_GRASP, GraspType.SPHERICAL_GRASP],\n            GraspType.LATERAL_PINCH: [GraspType.PINCH_GRASP, GraspType.POWER_GRASP],\n            GraspType.SPHERICAL_GRASP: [GraspType.POWER_GRASP, GraspType.PINCH_GRASP],\n            GraspType.CYLINDRICAL_GRASP: [GraspType.POWER_GRASP, GraspType.PINCH_GRASP]\n        }\n        return alternatives.get(primary_grasp, [])\n    \n    def _plan_specific_grasp(self, obj_props: ObjectProperties, grasp_type: GraspType, current_hand_pose: List[float]) -> Optional[GraspConfiguration]:\n        """Plan a specific type of grasp"""\n        # This would be called for alternative grasps\n        contact_points = self._plan_contact_points(obj_props, grasp_type)\n        contact_forces = self._calculate_contact_forces(obj_props, contact_points)\n        finger_positions = self._plan_finger_positions(contact_points, grasp_type)\n        \n        stability_score = self._evaluate_stability(\n            contact_points, \n            contact_forces, \n            obj_props.friction_coeff\n        )\n        \n        force_closure = self._check_force_closure(contact_points)\n        \n        return GraspConfiguration(\n            grasp_type=grasp_type,\n            contact_points=contact_points,\n            contact_forces=contact_forces,\n            finger_positions=finger_positions,\n            stability_score=stability_score,\n            force_closure=force_closure\n        )\n\n\nclass ManipulationController:\n    """Main controller for humanoid manipulation tasks"""\n    \n    def __init__(self, robot_arm_dof=7):\n        """\n        Initialize the manipulation controller\n        \n        :param robot_arm_dof: Degrees of freedom in the robot arm\n        """\n        self.grasp_planner = GraspPlanner()\n        self.arm_dof = robot_arm_dof\n        self.current_object = None\n        self.current_grasp = None\n        \n        # Robot state\n        self.hand_state = {\n            \'position\': [0.0, 0.0, 0.0],\n            \'orientation\': [0.0, 0.0, 0.0, 1.0],  # quaternion\n            \'finger_positions\': {finger: [0.0, 0.0, 0.0, 0.0] for finger in Finger},\n            \'gripper_state\': \'open\'  # \'open\', \'closed\', \'partially_open\'\n        }\n        \n        # Control parameters\n        self.impedance_params = {\n            \'position\': 100,  # N/m stiffness\n            \'orientation\': 10,  # Nm/rad stiffness\n            \'damping_ratio\': 1.0  # Critical damping\n        }\n        \n        self.force_limits = {\n            \'fingertip_normal\': 50,  # N\n            \'lateral_slip\': 10,     # N\n            \'torque\': 2            # Nm per joint\n        }\n    \n    def approach_object(self, obj_pose: List[float], approach_distance: float = 0.1) -> bool:\n        """\n        Move the hand to approach position near the object\n        \n        :param obj_pose: Object pose [x, y, z, qx, qy, qz, qw] (position + orientation)\n        :param approach_distance: Distance from object to start approach\n        :return: True if approach successful\n        """\n        # Calculate approach pose (slightly above and away from object)\n        obj_pos = obj_pose[:3]\n        obj_orient = obj_pose[3:]\n        \n        # For approach, we want to be at \'approach_distance\' away from object\n        # in a direction that makes sense for the planned grasp\n        approach_dir = [0, 0, 1]  # Default: approach from above\n        \n        approach_pos = [\n            obj_pos[0] + approach_dir[0] * approach_distance,\n            obj_pos[1] + approach_dir[1] * approach_distance,\n            obj_pos[2] + approach_dir[2] * approach_distance\n        ]\n        \n        # Move to approach position\n        success = self._move_to_pose(approach_pos, obj_orient)\n        \n        if success:\n            self.hand_state[\'position\'] = approach_pos[:]\n            self.hand_state[\'orientation\'] = obj_orient[:]\n        \n        return success\n    \n    def plan_and_execute_grasp(self, obj_props: ObjectProperties, obj_pose: List[float]) -> bool:\n        """\n        Plan and execute a grasp on the specified object\n        \n        :param obj_props: Properties of the object to grasp\n        :param obj_pose: Object pose [x, y, z, qx, qy, qz, qw]\n        :return: True if grasp successful\n        """\n        # Plan the grasp\n        grasp_config = self.grasp_planner.plan_grasp(obj_props, obj_pose)\n        \n        if grasp_config is None:\n            print("No suitable grasp configuration found")\n            return False\n        \n        self.current_grasp = grasp_config\n        print(f"Planned {grasp_config.grasp_type.value} with stability score {grasp_config.stability_score:.3f}")\n        \n        # Move to pre-grasp position\n        pre_grasp_pos = self._calculate_pre_grasp_position(obj_pose, grasp_config)\n        if not self._move_to_pose(pre_grasp_pos, obj_pose[3:]):  # Use same orientation\n            print("Failed to move to pre-grasp position")\n            return False\n        \n        # Execute the grasp\n        success = self._execute_grasp(grasp_config)\n        \n        if success:\n            self.current_object = obj_props\n            print("Grasp successful")\n        else:\n            print("Grasp failed")\n        \n        return success\n    \n    def _calculate_pre_grasp_position(self, obj_pose: List[float], grasp_config: GraspConfiguration) -> List[float]:\n        """Calculate position for pre-grasp approach"""\n        obj_pos = obj_pose[:3]\n        obj_orient = obj_pose[3:]\n        \n        # Simplified: approach from a safe distance along the approach direction\n        approach_offset = [0.05, 0.0, 0.0]  # 5cm offset\n        \n        # Transform offset to object frame\n        # This is a simplified transformation, real implementation would use full rotation\n        pre_grasp_pos = [\n            obj_pos[0] + approach_offset[0],\n            obj_pos[1] + approach_offset[1], \n            obj_pos[2] + approach_offset[2]\n        ]\n        \n        return pre_grasp_pos\n    \n    def _move_to_pose(self, position: List[float], orientation: List[float]) -> bool:\n        """Move the end-effector to specified pose (simulated)"""\n        # In a real implementation, this would call the robot\'s motion controller\n        # For this simulation, we\'ll just update the state\n        \n        # Simulate movement time\n        time.sleep(0.5)  # Simulate 0.5 seconds movement time\n        \n        self.hand_state[\'position\'] = position[:]\n        self.hand_state[\'orientation\'] = orientation[:]\n        \n        # In real implementation, check for collisions and path feasibility\n        return True\n    \n    def _execute_grasp(self, grasp_config: GraspConfiguration) -> bool:\n        """Execute the planned grasp"""\n        print(f"Executing {grasp_config.grasp_type.value} grasp")\n        \n        # 1. Move fingers to pre-contact positions\n        if not self._move_fingers_to_pre_contact(grasp_config):\n            return False\n        \n        # 2. Close fingers with appropriate forces\n        success = self._close_fingers_for_grasp(grasp_config)\n        \n        if success:\n            self.hand_state[\'gripper_state\'] = \'closed\'\n            # Update finger positions based on grasp configuration\n            self.hand_state[\'finger_positions\'] = grasp_config.finger_positions.copy()\n        else:\n            print("Grasp execution failed")\n        \n        return success\n    \n    def _move_fingers_to_pre_contact(self, grasp_config: GraspConfiguration) -> bool:\n        """Move fingers to positions just before contact for precision"""\n        # In a real implementation, this would move fingers to just before contact\n        # For simulation, we\'ll just wait\n        time.sleep(0.2)  # 200ms for pre-positioning\n        \n        return True\n    \n    def _close_fingers_for_grasp(self, grasp_config: GraspConfiguration) -> bool:\n        """Close fingers with appropriate forces for the grasp"""\n        # Apply forces gradually to avoid slippage\n        max_force = max(grasp_config.contact_forces) if grasp_config.contact_forces else 10.0\n        target_finger_positions = grasp_config.finger_positions\n        \n        # For simulation, we\'ll just update finger positions\n        # In real implementation, this would involve force control\n        for finger, position in target_finger_positions.items():\n            self.hand_state[\'finger_positions\'][finger] = position[:]\n        \n        # Check if grasp is stable\n        time.sleep(0.3)  # 300ms for fingers to close and stabilize\n        \n        # Simulate tactile feedback to verify grasp success\n        grasp_verified = self._verify_grasp_stability(grasp_config)\n        \n        return grasp_verified\n    \n    def _verify_grasp_stability(self, grasp_config: GraspConfiguration) -> bool:\n        """Verify that the grasp is stable"""\n        # In a real implementation, this would use tactile sensors\n        # For simulation, check the stability score from the planner\n        if grasp_config.stability_score >= self.grasp_planner.stability_threshold:\n            return True\n        else:\n            return False\n    \n    def release_object(self) -> bool:\n        """Release the currently grasped object"""\n        if self.hand_state[\'gripper_state\'] != \'closed\':\n            print("No object to release")\n            return False\n        \n        # Open fingers gradually to avoid dropping object suddenly\n        for finger in Finger:\n            self.hand_state[\'finger_positions\'][finger] = [0.0, 0.0, 0.0, 0.0]  # Open position\n        \n        self.hand_state[\'gripper_state\'] = \'open\'\n        \n        success = True  # In simulation, always successful\n        print("Object released")\n        \n        return success\n    \n    def move_object(self, target_pose: List[float]) -> bool:\n        """Move the currently grasped object to a target pose"""\n        if self.hand_state[\'gripper_state\'] != \'closed\':\n            print("No object grasped to move")\n            return False\n        \n        if not self._move_to_pose(target_pose[:3], target_pose[3:]):\n            print("Failed to move object to target pose")\n            return False\n        \n        print("Object moved to target position")\n        return True\n    \n    def get_manipulation_status(self) -> Dict[str, any]:\n        """Get current status of the manipulation system"""\n        return {\n            \'hand_position\': self.hand_state[\'position\'],\n            \'hand_orientation\': self.hand_state[\'orientation\'],\n            \'gripper_state\': self.hand_state[\'gripper_state\'],\n            \'holding_object\': self.current_object is not None,\n            \'current_grasp\': self.current_grasp.grasp_type.value if self.current_grasp else None,\n            \'impedance_params\': self.impedance_params,\n            \'force_limits\': self.force_limits\n        }\n\n\ndef main():\n    """Example usage of the humanoid manipulation system"""\n    print("Humanoid Manipulation System Example")\n    \n    # Initialize the manipulation controller\n    manipulator = ManipulationController()\n    \n    # Create an example object to manipulate\n    small_sphere = ObjectProperties(\n        shape=\'sphere\',\n        dimensions=[0.025],  # 2.5cm radius\n        weight=0.05,  # 50g\n        center_of_mass=[0.0, 0.0, 0.0],\n        friction_coeff=0.8,\n        material=\'plastic\',\n        fragility=0.3\n    )\n    \n    # Define object pose in world coordinates\n    sphere_pose = [0.5, 0.0, 0.2, 0.0, 0.0, 0.0, 1.0]  # x, y, z, qx, qy, qz, qw\n    \n    print(f"\\n--- Attempting to grasp sphere ---")\n    print(f"Object: sphere, radius 2.5cm, weight 50g")\n    print(f"Pose: [{sphere_pose[0]:.2f}, {sphere_pose[1]:.2f}, {sphere_pose[2]:.2f}]")\n    \n    # Approach the object\n    print("\\nApproaching object...")\n    if not manipulator.approach_object(sphere_pose, approach_distance=0.1):\n        print("Failed to approach object")\n        return\n    \n    # Plan and execute grasp\n    success = manipulator.plan_and_execute_grasp(small_sphere, sphere_pose)\n    \n    if success:\n        print("\\nGrasp successful!")\n        \n        # Show current status\n        status = manipulator.get_manipulation_status()\n        print(f"Current status: {status}")\n        \n        # Move object to a new location\n        new_pose = [0.5, 0.3, 0.4, 0.0, 0.0, 0.0, 1.0]  # New position\n        print(f"\\nMoving object to new location: [{new_pose[0]:.2f}, {new_pose[1]:.2f}, {new_pose[2]:.2f}]")\n        \n        move_success = manipulator.move_object(new_pose)\n        if move_success:\n            print("Object moved successfully!")\n        \n        # Release the object\n        print("\\nReleasing object...")\n        manipulator.release_object()\n        \n        # Check final status\n        final_status = manipulator.get_manipulation_status()\n        print(f"Final status: {final_status}")\n    else:\n        print("\\nGrasp failed!")\n    \n    # Test with a different object - a cylinder\n    print(f"\\n--- Attempting to grasp cylinder ---")\n    \n    cylinder = ObjectProperties(\n        shape=\'cylinder\',\n        dimensions=[0.015, 0.1],  # 1.5cm radius, 10cm height\n        weight=0.15,  # 150g\n        center_of_mass=[0.0, 0.0, 0.0],\n        friction_coeff=0.6,\n        material=\'metal\',\n        fragility=0.1\n    )\n    \n    cylinder_pose = [0.6, 0.0, 0.2, 0.0, 0.0, 0.0, 1.0]\n    \n    print(f"Object: cylinder, radius 1.5cm, height 10cm, weight 150g")\n    print(f"Pose: [{cylinder_pose[0]:.2f}, {cylinder_pose[1]:.2f}, {cylinder_pose[2]:.2f}]")\n    \n    # Approach and grasp the cylinder\n    manipulator.approach_object(cylinder_pose, approach_distance=0.1)\n    success2 = manipulator.plan_and_execute_grasp(cylinder, cylinder_pose)\n    \n    if success2:\n        print("Cylinder grasp successful!")\n        \n        # Show the planned grasp configuration\n        if manipulator.current_grasp:\n            print(f"Grasp type: {manipulator.current_grasp.grasp_type.value}")\n            print(f"Stability score: {manipulator.current_grasp.stability_score:.3f}")\n            print(f"Force closure: {manipulator.current_grasp.force_closure}")\n            print(f"Contact points: {len(manipulator.current_grasp.contact_points)}")\n    else:\n        print("Cylinder grasp failed!")\n    \n    print("\\nHumanoid manipulation system example completed")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"simulation-demonstration",children:"Simulation Demonstration"}),"\n",(0,s.jsx)(e.p,{children:"This implementation demonstrates sophisticated manipulation capabilities for humanoid robots, including grasp planning, dexterous control, and stable object handling. The system can adapt its grasping approach based on object properties and plan stable, force-closure grasps. The code can be integrated with robot simulation environments to test manipulation behaviors on virtual humanoid robots."}),"\n",(0,s.jsx)(e.h2,{id:"hands-on-lab-humanoid-manipulation-implementation",children:"Hands-On Lab: Humanoid Manipulation Implementation"}),"\n",(0,s.jsx)(e.p,{children:"In this lab, you'll implement and test advanced manipulation techniques for humanoid robots:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Set up the manipulation controller with grasp planning"}),"\n",(0,s.jsx)(e.li,{children:"Implement different grasp types for various objects"}),"\n",(0,s.jsx)(e.li,{children:"Test manipulation with objects of different shapes and properties"}),"\n",(0,s.jsx)(e.li,{children:"Implement force control for stable grasping"}),"\n",(0,s.jsx)(e.li,{children:"Evaluate the manipulation performance and dexterity"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"required-equipment",children:"Required Equipment:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"ROS 2 Humble environment"}),"\n",(0,s.jsx)(e.li,{children:"Robot simulation environment (Gazebo, Isaac Sim)"}),"\n",(0,s.jsx)(e.li,{children:"Humanoid robot model with manipulator arms"}),"\n",(0,s.jsx)(e.li,{children:"(Optional) Physical humanoid robot for testing"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"instructions",children:"Instructions:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["Create a new ROS 2 package: ",(0,s.jsx)(e.code,{children:"ros2 pkg create --build-type ament_python humanoid_manipulation"})]}),"\n",(0,s.jsx)(e.li,{children:"Implement the HandKinematics and GraspPlanner classes"}),"\n",(0,s.jsx)(e.li,{children:"Create a node that handles manipulation tasks"}),"\n",(0,s.jsx)(e.li,{children:"Test with different object shapes and properties"}),"\n",(0,s.jsx)(e.li,{children:"Implement force feedback and tactile sensing"}),"\n",(0,s.jsx)(e.li,{children:"Test grasp stability and adjustment strategies"}),"\n",(0,s.jsx)(e.li,{children:"Evaluate the system's manipulation success rate"}),"\n",(0,s.jsx)(e.li,{children:"Document the effectiveness of different grasp types"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"common-pitfalls--debugging-notes",children:"Common Pitfalls & Debugging Notes"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Singularities"}),": Watch for configurations where the hand loses degrees of freedom"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force Control"}),": Balancing enough force to grip without damaging objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Slippage"}),": Ensuring grasp stability when lifting or moving objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision Avoidance"}),": Preventing self-collisions during manipulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Model Accuracy"}),": Ensuring hand models match physical robots for real applications"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tactile Feedback"}),": Handling cases where objects slip during grasp"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic Objects"}),": Grasping objects that may move during approach"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary--key-terms",children:"Summary & Key Terms"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key Terms:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dexterous Manipulation"}),": Fine control of objects using multi-fingered hands"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Grasp Planning"}),": Computational methods to determine optimal grasp configurations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force Closure"}),": Property of a grasp that can resist any external force/torque"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Power Grasp"}),": Strong grasp using palm and multiple fingers"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Precision Grasp"}),": Fine control grasp using fingertips"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Hand Kinematics"}),": Geometric relationships in humanoid hand structure"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tactile Feedback"}),": Sensory information from touch and pressure"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"further-reading--citations",children:"Further Reading & Citations"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:'Feix, T., et al. (2009). "A comprehensive grasp taxonomy." RSS Workshop on Understanding the Human Hand for Advancing Robotic Manipulation.'}),"\n",(0,s.jsx)(e.li,{children:'Cutkosky, M. R. (1989). "On grasp choice, grasp models, and the design of hands for manufacturing tasks." IEEE Transactions on Robotics and Automation.'}),"\n",(0,s.jsx)(e.li,{children:'Roa, M. A., & Su\xe1rez, R. (2015). "Grasp quality metrics: review and performance." Autonomous Robots.'}),"\n",(0,s.jsx)(e.li,{children:'Ajoudani, A., et al. (2015). "The child-size SARAH rehab robot: Towards more effective robotic rehabilitation of gait and posture in children." IEEE International Conference on Rehabilitation Robotics.'}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Explain the different types of grasps and when each is most appropriate."}),"\n",(0,s.jsx)(e.li,{children:"What are the key factors in planning a stable grasp for an object?"}),"\n",(0,s.jsx)(e.li,{children:"Describe the role of tactile feedback in humanoid manipulation."}),"\n",(0,s.jsx)(e.li,{children:"How do you calculate whether a grasp achieves force closure?"}),"\n",(0,s.jsx)(e.li,{children:"What are the main challenges in implementing dexterous manipulation for humanoid robots?"}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Previous"}),": ",(0,s.jsx)(e.a,{href:"/docs/humanoid-robotics/hri",children:"Human-Robot Interaction"}),(0,s.jsx)(e.br,{}),"\n",(0,s.jsx)(e.strong,{children:"Next"}),": ",(0,s.jsx)(e.a,{href:"../../07-capstone/intro.md",children:"Capstone Project Introduction"})]})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);