"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[407],{4808:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"humanoid-robotics/intro","title":"Introduction to Humanoid Robotics","description":"Humanoid robotics represents one of the most ambitious fields in robotics, focusing on the design, development, and control of robots that physically resemble humans. These robots are characterized by their bipedal locomotion, dexterous manipulation capabilities, and often anthropomorphic form factor. Humanoid robots have the potential to operate in human environments, interact naturally with people, and perform tasks designed for humans.","source":"@site/docs/05-humanoid-robotics/intro.md","sourceDirName":"05-humanoid-robotics","slug":"/humanoid-robotics/intro","permalink":"/docs/humanoid-robotics/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/shaheryarshah/Hackthon_SpecKitPlus/edit/main/docs/docs/05-humanoid-robotics/intro.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"VSLAM and Navigation with Isaac ROS","permalink":"/docs/isaac-platform/vslam-nav2"},"next":{"title":"Humanoid Kinematics and Dynamics","permalink":"/docs/humanoid-robotics/kinematics"}}');var t=i(4848),s=i(8453);const l={},a="Introduction to Humanoid Robotics",r={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Anthropomorphic Design",id:"anthropomorphic-design",level:3},{value:"Degrees of Freedom and Actuation",id:"degrees-of-freedom-and-actuation",level:3},{value:"Control Challenges",id:"control-challenges",level:3},{value:"Equations and Models",id:"equations-and-models",level:2},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Inverse Kinematics for Humanoid Arms",id:"inverse-kinematics-for-humanoid-arms",level:3},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"Code Example: Basic Humanoid Kinematics",id:"code-example-basic-humanoid-kinematics",level:2},{value:"Simulation Demonstration",id:"simulation-demonstration",level:2},{value:"Hands-On Lab: Humanoid Robot Control",id:"hands-on-lab-humanoid-robot-control",level:2},{value:"Required Equipment:",id:"required-equipment",level:3},{value:"Instructions:",id:"instructions",level:3},{value:"Common Pitfalls &amp; Debugging Notes",id:"common-pitfalls--debugging-notes",level:2},{value:"Summary &amp; Key Terms",id:"summary--key-terms",level:2},{value:"Further Reading &amp; Citations",id:"further-reading--citations",level:2},{value:"Assessment Questions",id:"assessment-questions",level:2}];function d(n){const e={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"introduction-to-humanoid-robotics",children:"Introduction to Humanoid Robotics"})}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robotics represents one of the most ambitious fields in robotics, focusing on the design, development, and control of robots that physically resemble humans. These robots are characterized by their bipedal locomotion, dexterous manipulation capabilities, and often anthropomorphic form factor. Humanoid robots have the potential to operate in human environments, interact naturally with people, and perform tasks designed for humans."}),"\n",(0,t.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(e.p,{children:"After completing this chapter, you should be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand the fundamental challenges in humanoid robot design"}),"\n",(0,t.jsx)(e.li,{children:"Explain the principles of bipedal locomotion and balance control"}),"\n",(0,t.jsx)(e.li,{children:"Implement basic humanoid robot kinematics and dynamics"}),"\n",(0,t.jsx)(e.li,{children:"Design manipulation strategies for humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Evaluate human-robot interaction approaches for humanoid systems"}),"\n",(0,t.jsx)(e.li,{children:"Compare different humanoid robot platforms and their capabilities"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(e.h3,{id:"anthropomorphic-design",children:"Anthropomorphic Design"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots are designed to resemble humans, typically featuring:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Two arms with dexterous hands"}),"\n",(0,t.jsx)(e.li,{children:"Two legs for bipedal locomotion"}),"\n",(0,t.jsx)(e.li,{children:"A head with sensors (cameras, microphones, etc.)"}),"\n",(0,t.jsx)(e.li,{children:"A torso connecting the limbs and head"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"degrees-of-freedom-and-actuation",children:"Degrees of Freedom and Actuation"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots typically have 20-50+ degrees of freedom (DOF), each controlled by actuators. Key actuated joints include:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Hip joints (flexion/extension, abduction/adduction, rotation)"}),"\n",(0,t.jsx)(e.li,{children:"Knee joints (flexion/extension)"}),"\n",(0,t.jsx)(e.li,{children:"Ankle joints (dorsiflexion/plantarflexion, inversion/eversion)"}),"\n",(0,t.jsx)(e.li,{children:"Shoulder joints (multiple DOF for arm positioning)"}),"\n",(0,t.jsx)(e.li,{children:"Elbow joints (flexion/extension)"}),"\n",(0,t.jsx)(e.li,{children:"Wrist joints (flexion/extension, rotation)"}),"\n",(0,t.jsx)(e.li,{children:"Neck joints (for head orientation)"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"control-challenges",children:"Control Challenges"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots face unique control challenges:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Maintaining balance during locomotion and manipulation"}),"\n",(0,t.jsx)(e.li,{children:"Managing high-dimensional control spaces"}),"\n",(0,t.jsx)(e.li,{children:"Ensuring stability during dynamic movements"}),"\n",(0,t.jsx)(e.li,{children:"Adapting to environmental disturbances"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"equations-and-models",children:"Equations and Models"}),"\n",(0,t.jsx)(e.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,t.jsx)(e.p,{children:"The ZMP is a critical concept for humanoid balance control:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"ZMP_x = (\u03a3(F_z_i * x_i) - \u03a3(M_y_i)) / \u03a3(F_z_i)\nZMP_y = (\u03a3(F_z_i * y_i) - \u03a3(M_x_i)) / \u03a3(F_z_i)\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"F_z_i"})," is the vertical force at contact point i"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"(x_i, y_i)"})," is the position of contact point i"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"M_x_i"}),", ",(0,t.jsx)(e.code,{children:"M_y_i"})," are the moments about the x and y axes at contact point i"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"inverse-kinematics-for-humanoid-arms",children:"Inverse Kinematics for Humanoid Arms"}),"\n",(0,t.jsx)(e.p,{children:"For a humanoid arm with N joints, the inverse kinematics problem is:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u03b8* = argmin_\u03b8 ||f(\u03b8) - p_d||\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"\u03b8 = [\u03b8_1, \u03b8_2, ..., \u03b8_N]^T"})," is the joint angle vector"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"f(\u03b8)"})," is the forward kinematics function"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"p_d"})," is the desired end-effector position"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,t.jsx)(e.p,{children:"The LIPM is commonly used for humanoid walking:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u1e8d = \u03c9\xb2(x - x_zmp)\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"x"})," is the center of mass position"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"x_zmp"})," is the zero moment point position"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"\u03c9\xb2 = g/h"}),", with ",(0,t.jsx)(e.code,{children:"g"})," being gravity and ",(0,t.jsx)(e.code,{children:"h"})," the height of the COM"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"code-example-basic-humanoid-kinematics",children:"Code Example: Basic Humanoid Kinematics"}),"\n",(0,t.jsx)(e.p,{children:"Here's an example implementation of basic humanoid arm kinematics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport math\nfrom scipy.spatial.transform import Rotation as R\n\n\nclass HumanoidArmController:\n    """\n    A simple controller for a 6-DOF humanoid arm using inverse kinematics\n    """\n    def __init__(self, link_lengths=[0.3, 0.3, 0.1]):  # shoulder-elbow, elbow-wrist, wrist-end\n        """\n        Initialize the arm controller\n        :param link_lengths: List of link lengths [upper_arm, forearm, hand_offset]\n        """\n        self.l1, self.l2, self.l3 = link_lengths\n        self.arm_dh_params = self._define_dh_parameters()\n    \n    def _define_dh_parameters(self):\n        """\n        Define Denavit-Hartenberg parameters for the arm (simplified)\n        [theta, d, a, alpha]\n        For a simple 6-DOF arm, we define parameters for each joint\n        """\n        # For this example, using simplified joint model\n        # In practice, each joint would have its own DH parameters\n        return [\n            [0, 0, self.l1, 0],      # Shoulder joint\n            [0, 0, self.l2, 0],      # Elbow joint\n            [0, 0, self.l3, 0],      # Wrist joint\n            # Additional joints would be added for full 6-DOF\n        ]\n    \n    def forward_kinematics(self, joint_angles):\n        """\n        Calculate the end-effector position given joint angles\n        :param joint_angles: List of joint angles [shoulder, elbow, wrist]\n        :return: [x, y, z] position of end-effector\n        """\n        # Simplified forward kinematics for 3-DOF arm in 2D plane\n        # For a real 6-DOF arm, this would involve complex transformation matrices\n        \n        shoulder_angle, elbow_angle, wrist_angle = joint_angles\n        \n        # Calculate elbow position\n        elbow_x = self.l1 * math.cos(shoulder_angle)\n        elbow_y = self.l1 * math.sin(shoulder_angle)\n        \n        # Calculate wrist position\n        wrist_x = elbow_x + self.l2 * math.cos(shoulder_angle + elbow_angle)\n        wrist_y = elbow_y + self.l2 * math.sin(shoulder_angle + elbow_angle)\n        \n        # Calculate end-effector position\n        end_x = wrist_x + self.l3 * math.cos(shoulder_angle + elbow_angle + wrist_angle)\n        end_y = wrist_y + self.l3 * math.sin(shoulder_angle + elbow_angle + wrist_angle)\n        \n        return [end_x, end_y, 0.0]  # z=0 for 2D simplification\n    \n    def inverse_kinematics(self, target_pos, current_angles):\n        """\n        Calculate joint angles to reach target position\n        :param target_pos: [x, y, z] target position\n        :param current_angles: Current joint angles for reference\n        :return: New joint angles to reach target position\n        """\n        x, y, z = target_pos\n        \n        # Calculate distance to target\n        dist = math.sqrt(x**2 + y**2)\n        \n        # Check if target is reachable\n        max_reach = self.l1 + self.l2 + self.l3\n        if dist > max_reach:\n            # Target is out of reach, move to closest point\n            scale = max_reach / dist\n            x = x * scale\n            y = y * scale\n            dist = max_reach\n        \n        # Simplified inverse kinematics for 2D 2-DOF arm\n        # (The third joint would adjust the wrist angle)\n        \n        # Calculate elbow angle using law of cosines\n        cos_elbow = (self.l1**2 + self.l2**2 - dist**2) / (2 * self.l1 * self.l2)\n        cos_elbow = np.clip(cos_elbow, -1, 1)  # Clamp to avoid numerical errors\n        elbow_angle = math.pi - math.acos(cos_elbow)\n        \n        # Calculate shoulder angle\n        k1 = self.l1 + self.l2 * math.cos(elbow_angle)\n        k2 = self.l2 * math.sin(elbow_angle)\n        shoulder_angle = math.atan2(y, x) - math.atan2(k2, k1)\n        \n        # Calculate wrist angle to maintain orientation\n        # For this example, we\'ll maintain the current wrist angle\n        wrist_angle = current_angles[2] if len(current_angles) > 2 else 0\n        \n        return [shoulder_angle, elbow_angle, wrist_angle]\n    \n    def compute_jacobian(self, joint_angles):\n        """\n        Compute the Jacobian matrix for the arm\n        The Jacobian relates joint velocities to end-effector velocities\n        """\n        # Simplified 2D Jacobian for 3-DOF arm\n        # In full 3D, this would be a 6xN matrix (3 position + 3 orientation)\n        \n        q1, q2, q3 = joint_angles\n        \n        # Position of each joint\n        j1_x = 0\n        j1_y = 0\n        \n        j2_x = self.l1 * math.cos(q1)\n        j2_y = self.l1 * math.sin(q1)\n        \n        j3_x = j2_x + self.l2 * math.cos(q1 + q2)\n        j3_y = j2_y + self.l2 * math.sin(q1 + q2)\n        \n        # End-effector position\n        ex = j3_x + self.l3 * math.cos(q1 + q2 + q3)\n        ey = j3_y + self.l3 * math.sin(q1 + q2 + q3)\n        \n        # Compute Jacobian matrix (2x3: 2D position, 3 joints)\n        J = np.zeros((2, 3))\n        \n        # dx/dq1\n        J[0, 0] = -self.l1*math.sin(q1) - self.l2*math.sin(q1+q2) - self.l3*math.sin(q1+q2+q3)\n        # dy/dq1\n        J[1, 0] = self.l1*math.cos(q1) + self.l2*math.cos(q1+q2) + self.l3*math.cos(q1+q2+q3)\n        \n        # dx/dq2\n        J[0, 1] = -self.l2*math.sin(q1+q2) - self.l3*math.sin(q1+q2+q3)\n        # dy/dq2\n        J[1, 1] = self.l2*math.cos(q1+q2) + self.l3*math.cos(q1+q2+q3)\n        \n        # dx/dq3\n        J[0, 2] = -self.l3*math.sin(q1+q2+q3)\n        # dy/dq3\n        J[1, 2] = self.l3*math.cos(q1+q2+q3)\n        \n        return J\n\n\nclass HumanoidBalanceController:\n    """\n    A simple controller for humanoid balance using ZMP (Zero Moment Point)\n    """\n    def __init__(self, com_height=0.8, sample_time=0.01):\n        """\n        Initialize the balance controller\n        :param com_height: Height of the center of mass\n        :param sample_time: Controller sample time\n        """\n        self.com_height = com_height\n        self.sample_time = sample_time\n        self.g = 9.81  # Gravity constant\n        self.omega = math.sqrt(self.g / self.com_height)  # Natural frequency\n        \n        # State variables\n        self.com_x = 0.0\n        self.com_y = 0.0\n        self.com_x_dot = 0.0\n        self.com_y_dot = 0.0\n        \n        # Desired ZMP (initially at center)\n        self.zmp_desired_x = 0.0\n        self.zmp_desired_y = 0.0\n    \n    def update_balance(self, dt=0.01):\n        """\n        Update the balance control based on current COM state\n        """\n        # Using Linear Inverted Pendulum Model (LIPM)\n        # x_com_ddot = omega^2 * (x_com - zmp_desired_x)\n        \n        com_x_ddot = self.omega**2 * (self.com_x - self.zmp_desired_x)\n        com_y_ddot = self.omega**2 * (self.com_y - self.zmp_desired_y)\n        \n        # Update COM state with Euler integration\n        self.com_x_dot += com_x_ddot * dt\n        self.com_y_dot += com_y_ddot * dt\n        \n        self.com_x += self.com_x_dot * dt\n        self.com_y += self.com_y_dot * dt\n        \n        return [self.com_x, self.com_y], [self.com_x_dot, self.com_y_dot]\n    \n    def set_desired_zmp(self, x, y):\n        """\n        Set the desired ZMP position for balance control\n        """\n        self.zmp_desired_x = x\n        self.zmp_desired_y = y\n    \n    def compute_desired_com_trajectory(self, zmp_trajectory, duration=1.0):\n        """\n        Compute desired COM trajectory from a ZMP trajectory\n        """\n        # Simplified approach: follow ZMP with some offset\n        # In practice, this would involve more complex trajectory planning\n        \n        # For example, a simple preview control approach\n        # This is a simplified implementation\n        desired_com_x = zmp_trajectory[0]  # Follow ZMP with small offset\n        desired_com_y = zmp_trajectory[1]\n        \n        return [desired_com_x, desired_com_y]\n\n\ndef main():\n    # Example usage of the humanoid controllers\n    print("Humanoid Robotics Controller Example")\n    \n    # Initialize arm controller\n    arm = HumanoidArmController()\n    \n    # Example: Move arm to a specific position\n    current_angles = [0.0, 0.0, 0.0]  # Shoulder, elbow, wrist angles\n    \n    # Calculate forward kinematics\n    end_pos = arm.forward_kinematics(current_angles)\n    print(f"Current end-effector position: {end_pos}")\n    \n    # Calculate inverse kinematics for target position\n    target_pos = [0.4, 0.3, 0.0]\n    new_angles = arm.inverse_kinematics(target_pos, current_angles)\n    print(f"Required joint angles for target {target_pos}: {new_angles}")\n    \n    # Verify with forward kinematics\n    final_pos = arm.forward_kinematics(new_angles)\n    print(f"Final end-effector position: {final_pos}")\n    \n    # Calculate Jacobian\n    jacobian = arm.compute_jacobian(new_angles)\n    print(f"Jacobian matrix:\\n{jacobian}")\n    \n    # Initialize balance controller\n    balance = HumanoidBalanceController()\n    \n    # Set desired ZMP (center of support polygon)\n    balance.set_desired_zmp(0.0, 0.0)\n    \n    # Simulate balance for 1 second\n    print("\\nBalance simulation for 1 second:")\n    for t in np.arange(0, 1.0, 0.1):\n        com_pos, com_vel = balance.update_balance(0.1)\n        print(f"Time {t:.1f}s - COM: [{com_pos[0]:.3f}, {com_pos[1]:.3f}]")\n    \n    print("\\nHumanoid robot controllers initialized successfully")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,t.jsx)(e.h2,{id:"simulation-demonstration",children:"Simulation Demonstration"}),"\n",(0,t.jsx)(e.p,{children:"This controller demonstrates fundamental concepts in humanoid robotics, including kinematics for manipulation and balance control. The code can be integrated with simulation environments like Gazebo or Isaac Sim to test these control strategies on virtual humanoid robots."}),"\n",(0,t.jsx)(e.h2,{id:"hands-on-lab-humanoid-robot-control",children:"Hands-On Lab: Humanoid Robot Control"}),"\n",(0,t.jsx)(e.p,{children:"In this lab, you'll implement basic control for a humanoid robot:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Set up a humanoid robot simulation environment"}),"\n",(0,t.jsx)(e.li,{children:"Implement kinematic controllers for manipulation"}),"\n",(0,t.jsx)(e.li,{children:"Design a balance controller using ZMP"}),"\n",(0,t.jsx)(e.li,{children:"Test the controllers with various movement patterns"}),"\n",(0,t.jsx)(e.li,{children:"Evaluate the stability and accuracy of the control system"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"required-equipment",children:"Required Equipment:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"ROS 2 Humble environment"}),"\n",(0,t.jsx)(e.li,{children:"Gazebo or Isaac Sim"}),"\n",(0,t.jsx)(e.li,{children:"Humanoid robot model (e.g., Atlas, NAO, or custom model)"}),"\n",(0,t.jsx)(e.li,{children:"Python development environment"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"instructions",children:"Instructions:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["Install a humanoid robot simulation package (e.g., ",(0,t.jsx)(e.code,{children:"ros2_control"}),", Gazebo models)"]}),"\n",(0,t.jsxs)(e.li,{children:["Create a new ROS 2 package for humanoid control: ",(0,t.jsx)(e.code,{children:"ros2 pkg create --build-type ament_python humanoid_control"})]}),"\n",(0,t.jsx)(e.li,{children:"Implement the HumanoidArmController and HumanoidBalanceController classes"}),"\n",(0,t.jsx)(e.li,{children:"Create launch files to start the simulation with your controllers"}),"\n",(0,t.jsx)(e.li,{children:"Test with different target positions for the arm"}),"\n",(0,t.jsx)(e.li,{children:"Evaluate balance control under disturbances"}),"\n",(0,t.jsx)(e.li,{children:"Document the performance and limitations of your controllers"}),"\n",(0,t.jsx)(e.li,{children:"Experiment with different control parameters"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"common-pitfalls--debugging-notes",children:"Common Pitfalls & Debugging Notes"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Singularity Issues"}),": Inverse kinematics may fail at singular configurations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint Limits"}),": Ensure calculated joint angles are within physical limits"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Balance Stability"}),": Small disturbances can cause instability in bipedal locomotion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Computational Load"}),": Real-time control requires efficient algorithms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Calibration"}),": Ensure accurate robot kinematic parameters for successful control"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary--key-terms",children:"Summary & Key Terms"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Terms:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Humanoid Robot"}),": Robot designed to resemble human form and behavior"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Degrees of Freedom (DOF)"}),": Number of independent joint movements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": Point where the net moment of ground reaction forces is zero"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Inverse Kinematics"}),": Calculating joint angles to achieve desired end-effector position"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Forward Kinematics"}),": Calculating end-effector position from joint angles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Center of Mass (COM)"}),": Point where all mass is concentrated for dynamics analysis"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bipedal Locomotion"}),": Walking on two legs"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Linear Inverted Pendulum Model (LIPM)"}),": Simplified model for balance control"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"further-reading--citations",children:"Further Reading & Citations"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Kajita, S. (2023). Humanoid Robot Control: A Survey. IEEE Transactions on Robotics."}),"\n",(0,t.jsx)(e.li,{children:"Sardain, P., & Bessonnet, G. (2004). Forces acting on a biped robot. Centre of pressure zero moment point. IEEE Transactions on Systems, Man, and Cybernetics, Part A: Systems and Humans."}),"\n",(0,t.jsx)(e.li,{children:"Khatib, O., et al. (2018). Dynamic locomotion: A framework for whole-body control. IEEE Robotics & Automation Magazine."}),"\n",(0,t.jsx)(e.li,{children:"Hyon, S., et al. (2007). Full-body compliant human\u2013robot interaction: Initial experiments. Robotics and Autonomous Systems."}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Explain the concept of Zero Moment Point (ZMP) and its importance in humanoid balance control."}),"\n",(0,t.jsx)(e.li,{children:"What are the main differences between kinematic and dynamic control for humanoid robots?"}),"\n",(0,t.jsx)(e.li,{children:"Describe the challenges of inverse kinematics for redundant manipulator systems."}),"\n",(0,t.jsx)(e.li,{children:"How does the Linear Inverted Pendulum Model (LIPM) simplify humanoid walking control?"}),"\n",(0,t.jsx)(e.li,{children:"What factors influence the stability of bipedal locomotion in humanoid robots?"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Previous"}),": ",(0,t.jsx)(e.a,{href:"/docs/isaac-platform/vslam-nav2",children:"VSLAM and Navigation with Isaac ROS"}),(0,t.jsx)(e.br,{}),"\n",(0,t.jsx)(e.strong,{children:"Next"}),": ",(0,t.jsx)(e.a,{href:"/docs/humanoid-robotics/kinematics",children:"Humanoid Kinematics and Dynamics"})]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>a});var o=i(6540);const t={},s=o.createContext(t);function l(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);