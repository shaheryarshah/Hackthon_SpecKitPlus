"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[800],{5577:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"humanoid-robotics/kinematics","title":"Humanoid Kinematics and Dynamics","description":"Humanoid kinematics and dynamics form the mathematical foundation for understanding and controlling the motion of humanoid robots. Kinematics deals with the geometric relationships between joints and end-effectors without considering forces, while dynamics includes the effects of forces, torques, masses, and accelerations. This section covers both forward and inverse kinematics as well as dynamic modeling approaches for humanoid robots.","source":"@site/docs/05-humanoid-robotics/kinematics.md","sourceDirName":"05-humanoid-robotics","slug":"/humanoid-robotics/kinematics","permalink":"/Hackthon_SpecKitPlus/docs/humanoid-robotics/kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/shaheryarshah/Hackthon_SpecKitPlus/edit/main/docs/docs/05-humanoid-robotics/kinematics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Humanoid Robotics","permalink":"/Hackthon_SpecKitPlus/docs/humanoid-robotics/intro"},"next":{"title":"Bipedal Locomotion and Walking Control","permalink":"/Hackthon_SpecKitPlus/docs/humanoid-robotics/locomotion"}}');var a=e(4848),o=e(8453);const r={},s="Humanoid Kinematics and Dynamics",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Workspace Analysis",id:"workspace-analysis",level:3},{value:"Jacobian Matrix",id:"jacobian-matrix",level:3},{value:"Dynamics Modeling",id:"dynamics-modeling",level:3},{value:"Equations and Models",id:"equations-and-models",level:2},{value:"Forward Kinematics with Homogeneous Transformations",id:"forward-kinematics-with-homogeneous-transformations",level:3},{value:"Denavit-Hartenberg Transformation",id:"denavit-hartenberg-transformation",level:3},{value:"Inverse Kinematics Optimization",id:"inverse-kinematics-optimization",level:3},{value:"Jacobian Matrix",id:"jacobian-matrix-1",level:3},{value:"Lagrange-Euler Dynamics",id:"lagrange-euler-dynamics",level:3},{value:"Code Example: Advanced Humanoid Kinematics and Dynamics",id:"code-example-advanced-humanoid-kinematics-and-dynamics",level:2},{value:"Simulation Demonstration",id:"simulation-demonstration",level:2},{value:"Hands-On Lab: Humanoid Kinematics and Dynamics Implementation",id:"hands-on-lab-humanoid-kinematics-and-dynamics-implementation",level:2},{value:"Required Equipment:",id:"required-equipment",level:3},{value:"Instructions:",id:"instructions",level:3},{value:"Common Pitfalls &amp; Debugging Notes",id:"common-pitfalls--debugging-notes",level:2},{value:"Summary &amp; Key Terms",id:"summary--key-terms",level:2},{value:"Further Reading &amp; Citations",id:"further-reading--citations",level:2},{value:"Assessment Questions",id:"assessment-questions",level:2}];function d(n){const i={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"humanoid-kinematics-and-dynamics",children:"Humanoid Kinematics and Dynamics"})}),"\n",(0,a.jsx)(i.p,{children:"Humanoid kinematics and dynamics form the mathematical foundation for understanding and controlling the motion of humanoid robots. Kinematics deals with the geometric relationships between joints and end-effectors without considering forces, while dynamics includes the effects of forces, torques, masses, and accelerations. This section covers both forward and inverse kinematics as well as dynamic modeling approaches for humanoid robots."}),"\n",(0,a.jsx)(i.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,a.jsx)(i.p,{children:"After completing this section, you should be able to:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Calculate forward and inverse kinematics for humanoid robot arms and legs"}),"\n",(0,a.jsx)(i.li,{children:"Understand the Denavit-Hartenberg (DH) parameters for kinematic modeling"}),"\n",(0,a.jsx)(i.li,{children:"Apply the Jacobian matrix to relate joint velocities to end-effector velocities"}),"\n",(0,a.jsx)(i.li,{children:"Analyze the dynamics of humanoid robots using Lagrange equations"}),"\n",(0,a.jsx)(i.li,{children:"Implement numerical methods for inverse kinematics solutions"}),"\n",(0,a.jsx)(i.li,{children:"Evaluate the stability and workspace of humanoid robot mechanisms"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(i.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,a.jsx)(i.p,{children:"Forward kinematics calculates the position and orientation of the end-effector given the joint angles. For a humanoid robot, this is essential for knowing where each part of the robot is in space."}),"\n",(0,a.jsx)(i.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,a.jsx)(i.p,{children:"Inverse kinematics determines the required joint angles to achieve a desired end-effector position and orientation. This is crucial for motion planning and task execution."}),"\n",(0,a.jsx)(i.h3,{id:"workspace-analysis",children:"Workspace Analysis"}),"\n",(0,a.jsx)(i.p,{children:"Understanding the reachable workspace of humanoid limbs is important for task planning and determining if a robot can perform a required action."}),"\n",(0,a.jsx)(i.h3,{id:"jacobian-matrix",children:"Jacobian Matrix"}),"\n",(0,a.jsx)(i.p,{children:"The Jacobian matrix relates joint space velocities to Cartesian space velocities. It's crucial for motion control, singularity analysis, and force control."}),"\n",(0,a.jsx)(i.h3,{id:"dynamics-modeling",children:"Dynamics Modeling"}),"\n",(0,a.jsx)(i.p,{children:"Dynamics modeling involves understanding how forces and torques affect the motion of the robot. For humanoid robots, this is essential for balance control and dynamic movements."}),"\n",(0,a.jsx)(i.h2,{id:"equations-and-models",children:"Equations and Models"}),"\n",(0,a.jsx)(i.h3,{id:"forward-kinematics-with-homogeneous-transformations",children:"Forward Kinematics with Homogeneous Transformations"}),"\n",(0,a.jsx)(i.p,{children:"For an n-DOF robot, the forward kinematics is calculated as:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"T_0^n = A_1(\u03b8_1) * A_2(\u03b8_2) * ... * A_n(\u03b8_n)\n"})}),"\n",(0,a.jsxs)(i.p,{children:["Where ",(0,a.jsx)(i.code,{children:"T_0^n"})," is the transformation matrix from the base frame to the end-effector frame, and ",(0,a.jsx)(i.code,{children:"A_i(\u03b8_i)"})," is the transformation matrix for joint i."]}),"\n",(0,a.jsx)(i.h3,{id:"denavit-hartenberg-transformation",children:"Denavit-Hartenberg Transformation"}),"\n",(0,a.jsx)(i.p,{children:"The DH transformation matrix for joint i is:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"     \u23a1 cos(\u03b8_i)   -sin(\u03b8_i)*cos(\u03b1_i)   sin(\u03b8_i)*sin(\u03b1_i)   a_i*cos(\u03b8_i) \u23a4\nA_i = \u23a2 sin(\u03b8_i)    cos(\u03b8_i)*cos(\u03b1_i)  -cos(\u03b8_i)*sin(\u03b1_i)   a_i*sin(\u03b8_i) \u23a5\n      \u23a2    0           sin(\u03b1_i)            cos(\u03b1_i)            d_i     \u23a5\n      \u23a3    0              0                  0                1       \u23a6\n"})}),"\n",(0,a.jsx)(i.p,{children:"Where \u03b8_i, d_i, a_i, and \u03b1_i are the DH parameters."}),"\n",(0,a.jsx)(i.h3,{id:"inverse-kinematics-optimization",children:"Inverse Kinematics Optimization"}),"\n",(0,a.jsx)(i.p,{children:"The inverse kinematics problem can be formulated as:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"min_\u03b8 ||f(\u03b8) - x_d||\xb2\n"})}),"\n",(0,a.jsxs)(i.p,{children:["Where ",(0,a.jsx)(i.code,{children:"f(\u03b8)"})," is the forward kinematics function, ",(0,a.jsx)(i.code,{children:"x_d"})," is the desired end-effector pose, and ",(0,a.jsx)(i.code,{children:"\u03b8"})," is the vector of joint angles."]}),"\n",(0,a.jsx)(i.h3,{id:"jacobian-matrix-1",children:"Jacobian Matrix"}),"\n",(0,a.jsx)(i.p,{children:"The geometric Jacobian is defined as:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"J(\u03b8) = \u2202f(\u03b8)/\u2202\u03b8\n"})}),"\n",(0,a.jsx)(i.p,{children:"For a 6-DOF manipulator, this results in a 6\xd7n matrix (n = number of joints):"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"J = [J_v ]  (6\xd7n)\n    [J_\u03c9 ]\n"})}),"\n",(0,a.jsxs)(i.p,{children:["Where ",(0,a.jsx)(i.code,{children:"J_v"})," is the linear velocity Jacobian and ",(0,a.jsx)(i.code,{children:"J_\u03c9"})," is the angular velocity Jacobian."]}),"\n",(0,a.jsx)(i.h3,{id:"lagrange-euler-dynamics",children:"Lagrange-Euler Dynamics"}),"\n",(0,a.jsx)(i.p,{children:"The dynamic equation for a robotic manipulator is:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"M(q)q\u0308 + C(q, q\u0307)q\u0307 + G(q) = \u03c4\n"})}),"\n",(0,a.jsx)(i.p,{children:"Where:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"M(q)"})," is the inertia matrix"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"C(q, q\u0307)"})," contains centrifugal and Coriolis terms"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"G(q)"})," is the gravity vector"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"\u03c4"})," is the vector of joint torques"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"q"}),", ",(0,a.jsx)(i.code,{children:"q\u0307"}),", ",(0,a.jsx)(i.code,{children:"q\u0308"})," are joint position, velocity, and acceleration vectors"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"code-example-advanced-humanoid-kinematics-and-dynamics",children:"Code Example: Advanced Humanoid Kinematics and Dynamics"}),"\n",(0,a.jsx)(i.p,{children:"Here's an example implementation of advanced kinematics and dynamics for a humanoid robot:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:'import numpy as np\nimport math\nfrom scipy.spatial.transform import Rotation as R\nfrom scipy.optimize import minimize\nfrom scipy.linalg import block_diag\n\n\nclass HumanoidKinematicsDynamics:\n    """\n    Advanced kinematics and dynamics for a humanoid robot\n    """\n    def __init__(self, robot_config):\n        """\n        Initialize the humanoid model with robot configuration\n        \n        :param robot_config: Dictionary containing link lengths, joint limits, and DH parameters\n        """\n        self.config = robot_config\n        self.num_joints = len(robot_config[\'dh_params\'])\n        \n        # Extract DH parameters\n        self.dh_params = robot_config[\'dh_params\']  # List of [a, alpha, d, theta_offset]\n        self.joint_limits = robot_config.get(\'joint_limits\', [(-np.pi, np.pi)] * self.num_joints)\n        \n        # Link properties for dynamics\n        self.link_masses = robot_config.get(\'link_masses\', [1.0] * self.num_joints)\n        self.link_com = robot_config.get(\'link_com\', [[0, 0, 0]] * self.num_joints)  # Center of mass in link frame\n        self.link_inertia = robot_config.get(\'link_inertia\', [np.eye(3)] * self.num_joints)  # Inertia tensor in COM frame\n        \n    def dh_transform(self, a, alpha, d, theta):\n        """\n        Calculate the Denavit-Hartenberg transformation matrix\n        """\n        return np.array([\n            [math.cos(theta), -math.sin(theta)*math.cos(alpha),  math.sin(theta)*math.sin(alpha), a*math.cos(theta)],\n            [math.sin(theta),  math.cos(theta)*math.cos(alpha), -math.cos(theta)*math.sin(alpha), a*math.sin(theta)],\n            [0,               math.sin(alpha),                   math.cos(alpha),               d],\n            [0,               0,                                 0,                             1]\n        ])\n    \n    def forward_kinematics(self, joint_angles, link_index=None):\n        """\n        Calculate forward kinematics for the entire chain or up to a specific link\n        \n        :param joint_angles: List of joint angles\n        :param link_index: Index of the link to calculate FK for (None for end-effector)\n        :return: 4x4 transformation matrix\n        """\n        if link_index is None:\n            link_index = len(self.dh_params)\n        \n        T = np.eye(4)  # Identity transformation\n        \n        for i in range(link_index):\n            a, alpha, d, theta_offset = self.dh_params[i]\n            theta = joint_angles[i] + theta_offset\n            \n            A_i = self.dh_transform(a, alpha, d, theta)\n            T = T @ A_i\n        \n        return T\n    \n    def get_end_effector_pose(self, joint_angles):\n        """\n        Get the position and orientation of the end-effector\n        """\n        T = self.forward_kinematics(joint_angles)\n        position = T[:3, 3]\n        orientation = R.from_matrix(T[:3, :3]).as_quat()\n        return position, orientation\n    \n    def jacobian(self, joint_angles, point_index=6):\n        """\n        Calculate the geometric Jacobian matrix for a 6-DOF robot\n        \n        :param joint_angles: List of joint angles\n        :param point_index: Index of the point to calculate Jacobian for (default: end-effector)\n        :return: 6xN Jacobian matrix (linear and angular velocities)\n        """\n        num_joints = len(joint_angles)\n        J = np.zeros((6, num_joints))\n        \n        # Get end-effector transform\n        T_end = self.forward_kinematics(joint_angles)\n        p_end = T_end[:3, 3]  # End-effector position\n        \n        # Calculate Jacobian columns for each joint\n        for i in range(num_joints):\n            # Transform of joint i\n            T_i = self.forward_kinematics(joint_angles, i)\n            p_i = T_i[:3, 3]  # Position of joint i\n            \n            # Z-axis of joint i in base frame\n            z_i = T_i[:3, 2]\n            \n            # Calculate Jacobian column\n            J[:3, i] = np.cross(z_i, (p_end - p_i))  # Linear velocity part\n            J[3:, i] = z_i  # Angular velocity part\n        \n        return J\n    \n    def inverse_kinematics(self, target_pos, target_rot, current_angles, max_iter=100, tolerance=1e-4):\n        """\n        Solve inverse kinematics using iterative method (Jacobian transpose/pseudoinverse)\n        \n        :param target_pos: Target position [x, y, z]\n        :param target_rot: Target rotation as quaternion [x, y, z, w]\n        :param current_angles: Initial joint configuration\n        :param max_iter: Maximum iterations\n        :param tolerance: Position tolerance\n        :return: Joint angles that reach the target\n        """\n        # Convert target rotation to matrix\n        target_rot_matrix = R.from_quat(target_rot).as_matrix()\n        \n        # Create target transformation matrix\n        target_transform = np.eye(4)\n        target_transform[:3, 3] = target_pos\n        target_transform[:3, :3] = target_rot_matrix\n        \n        q = np.array(current_angles, dtype=float)\n        \n        for iteration in range(max_iter):\n            # Calculate current end-effector pose\n            current_transform = self.forward_kinematics(q)\n            \n            # Calculate pose error\n            pos_error = target_pos - current_transform[:3, 3]\n            \n            # For rotation error, use simple approach with angle-axis representation\n            R_current = current_transform[:3, :3]\n            R_target = target_transform[:3, :3]\n            R_error = R_target @ R_current.T\n            angle, axis = self.rotation_matrix_to_angle_axis(R_error)\n            rot_error = angle * axis\n            \n            # Combine position and rotation errors\n            error = np.concatenate([pos_error, rot_error])\n            \n            # Check if within tolerance\n            if np.linalg.norm(pos_error) < tolerance:\n                break\n            \n            # Calculate Jacobian\n            J = self.jacobian(q)\n            \n            # Use damped least squares for better stability\n            damping = 0.01\n            JJT = J @ J.T\n            I = np.eye(6)\n            J_pinv = J.T @ np.linalg.inv(JJT + damping**2 * I)\n            \n            # Update joint angles\n            dq = J_pinv @ error\n            q = q + 0.1 * dq  # Use step size to prevent overshooting\n            \n            # Apply joint limits\n            for i in range(len(q)):\n                q[i] = np.clip(q[i], self.joint_limits[i][0], self.joint_limits[i][1])\n        \n        return q.tolist()\n    \n    def rotation_matrix_to_angle_axis(self, R_matrix):\n        """\n        Convert rotation matrix to angle-axis representation\n        """\n        # Calculate angle\n        angle = math.acos(np.clip((np.trace(R_matrix) - 1) / 2, -1, 1))\n        \n        # Calculate axis (avoid division by zero)\n        if angle < 1e-6:\n            return 0.0, np.array([1, 0, 0])\n        \n        # Calculate axis\n        axis = np.array([\n            R_matrix[2, 1] - R_matrix[1, 2],\n            R_matrix[0, 2] - R_matrix[2, 0],\n            R_matrix[1, 0] - R_matrix[0, 1]\n        ])\n        axis = axis / (2 * math.sin(angle))\n        axis = axis / np.linalg.norm(axis)  # Normalize\n        \n        return angle, axis\n    \n    def compute_inertia_matrix(self, joint_angles):\n        """\n        Compute the joint space inertia matrix M(q) using the Composite Rigid Body Algorithm\n        Simplified implementation for demonstration\n        """\n        n = len(joint_angles)\n        M = np.zeros((n, n))\n        \n        # For a simplified implementation, we\'ll use an approximation\n        # In a real implementation, this would use the composite rigid body algorithm\n        for i in range(n):\n            # Approximate diagonal terms with link masses and positions\n            T_i = self.forward_kinematics(joint_angles, i+1)\n            p_i = T_i[:3, 3]  # Position of link i\n            \n            # Simplified inertia contribution (not physically accurate but demonstrates concept)\n            M[i, i] = self.link_masses[i] * np.linalg.norm(p_i)**2\n            \n            # Add terms for off-diagonal elements based on geometric coupling\n            for j in range(i):\n                T_j = self.forward_kinematics(joint_angles, j+1)\n                p_j = T_j[:3, 3]\n                \n                # Simplified coupling term\n                M[i, j] = M[j, i] = 0.1 * self.link_masses[i] * self.link_masses[j] * np.dot(p_i, p_j) / (1 + abs(i-j))\n        \n        return M\n    \n    def compute_coriolis_gravity(self, joint_angles, joint_velocities):\n        """\n        Compute Coriolis/centrifugal and gravity terms\n        Simplified implementation for demonstration\n        """\n        n = len(joint_angles)\n        C = np.zeros(n)  # Coriolis/centrifugal terms\n        G = np.zeros(n)  # Gravity terms\n        \n        # Simplified gravity term calculation\n        for i in range(n):\n            # Gravity effect based on joint angle (simplified)\n            G[i] = self.link_masses[i] * 9.81 * math.sin(joint_angles[i])\n        \n        # Simplified Coriolis term\n        for i in range(n):\n            # Centrifugal effect based on velocity squared\n            C[i] = 0.1 * joint_velocities[i] * abs(joint_velocities[i])\n            \n            # Coriolis coupling with other joints\n            for j in range(n):\n                if i != j:\n                    C[i] += 0.05 * joint_velocities[i] * joint_velocities[j]\n        \n        return C, G\n    \n    def inverse_dynamics(self, joint_angles, joint_velocities, joint_accelerations):\n        """\n        Compute required joint torques using inverse dynamics (Lagrange-Euler method)\n        \n        :param joint_angles: Joint position vector\n        :param joint_velocities: Joint velocity vector\n        :param joint_accelerations: Joint acceleration vector\n        :return: Required joint torques\n        """\n        # Compute inertia matrix\n        M = self.compute_inertia_matrix(joint_angles)\n        \n        # Compute Coriolis/centrifugal and gravity terms\n        C, G = self.compute_coriolis_gravity(joint_angles, joint_velocities)\n        \n        # Compute required torques: \u03c4 = M(q)q\u0308 + C(q, q\u0307)q\u0307 + G(q)\n        joint_acc_vec = np.array(joint_accelerations)\n        tau = M @ joint_acc_vec + C + G\n        \n        return tau\n    \n    def forward_dynamics(self, joint_angles, joint_velocities, joint_torques):\n        """\n        Compute joint accelerations from applied torques (forward dynamics)\n        \n        :param joint_angles: Joint position vector\n        :param joint_velocities: Joint velocity vector\n        :param joint_torques: Applied joint torque vector\n        :return: Joint accelerations\n        """\n        # Compute inertia matrix\n        M = self.compute_inertia_matrix(joint_angles)\n        \n        # Compute Coriolis/centrifugal and gravity terms\n        C, G = self.compute_coriolis_gravity(joint_angles, joint_velocities)\n        \n        # Compute accelerations: q\u0308 = M\u207b\xb9(\u03c4 - C(q, q\u0307)q\u0307 - G(q))\n        tau_vec = np.array(joint_torques)\n        qddot = np.linalg.inv(M) @ (tau_vec - C - G)\n        \n        return qddot\n\n\ndef main():\n    # Example usage of the advanced humanoid kinematics and dynamics\n    print("Advanced Humanoid Kinematics and Dynamics Example")\n    \n    # Define a simple 6-DOF humanoid arm configuration\n    robot_config = {\n        \'dh_params\': [\n            [0.0, np.pi/2, 0.1, 0.0],  # Joint 1: Shoulder rotation\n            [0.3, 0.0, 0.0, 0.0],      # Joint 2: Shoulder flexion\n            [0.0, np.pi/2, 0.0, 0.0],  # Joint 3: Shoulder abduction\n            [0.0, -np.pi/2, 0.3, 0.0], # Joint 4: Elbow flexion\n            [0.0, np.pi/2, 0.0, 0.0],  # Joint 5: Wrist flexion\n            [0.0, 0.0, 0.1, 0.0]       # Joint 6: Wrist rotation\n        ],\n        \'joint_limits\': [\n            (-np.pi, np.pi),   # Shoulder rotation\n            (-np.pi/2, np.pi/2),  # Shoulder flexion\n            (-np.pi/4, np.pi/4),  # Shoulder abduction\n            (0, np.pi),        # Elbow flexion\n            (-np.pi/2, np.pi/2),  # Wrist flexion\n            (-np.pi, np.pi)    # Wrist rotation\n        ],\n        \'link_masses\': [2.0, 1.5, 1.0, 1.2, 0.5, 0.3],  # Mass of each link\n        \'link_com\': [\n            [0.0, 0.0, 0.05],   # COM of link 1\n            [0.15, 0.0, 0.0],   # COM of link 2\n            [0.0, 0.0, 0.0],    # COM of link 3\n            [0.0, 0.0, 0.15],   # COM of link 4\n            [0.0, 0.0, 0.0],    # COM of link 5\n            [0.0, 0.0, 0.05]    # COM of link 6\n        ]\n    }\n    \n    # Initialize the humanoid model\n    robot = HumanoidKinematicsDynamics(robot_config)\n    \n    # Test forward kinematics\n    initial_angles = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    T = robot.forward_kinematics(initial_angles)\n    print(f"Initial end-effector transform:\\n{T}")\n    \n    # Get end-effector pose\n    pos, quat = robot.get_end_effector_pose(initial_angles)\n    print(f"Initial end-effector pose: pos={pos}, quat={quat}")\n    \n    # Calculate Jacobian\n    J = robot.jacobian(initial_angles)\n    print(f"Jacobian matrix shape: {J.shape}")\n    print(f"Jacobian at initial configuration:\\n{J}")\n    \n    # Test inverse kinematics\n    target_pos = [0.3, 0.2, 0.4]\n    target_rot = R.from_euler(\'xyz\', [0, 0, 0]).as_quat()  # No rotation\n    \n    solution = robot.inverse_kinematics(target_pos, target_rot, initial_angles)\n    print(f"IK solution: {solution}")\n    \n    # Verify the solution\n    final_pos, final_quat = robot.get_end_effector_pose(solution)\n    print(f"Reached position: {final_pos}, target position: {target_pos}")\n    print(f"Position error: {np.linalg.norm(np.array(final_pos) - np.array(target_pos))}")\n    \n    # Test dynamics calculations\n    joint_angles = [0.1, 0.2, -0.1, 0.3, 0.05, -0.2]\n    joint_velocities = [0.1, 0.15, -0.05, 0.2, 0.1, -0.1]\n    joint_accelerations = [0.05, 0.05, -0.02, 0.1, 0.05, -0.05]\n    \n    # Compute inertia matrix\n    M = robot.compute_inertia_matrix(joint_angles)\n    print(f"Inertia matrix shape: {M.shape}")\n    print(f"Diagonal elements of inertia matrix: {np.diag(M)}")\n    \n    # Compute Coriolis and gravity terms\n    C, G = robot.compute_coriolis_gravity(joint_angles, joint_velocities)\n    print(f"Coriolis terms: {C}")\n    print(f"Gravity terms: {G}")\n    \n    # Compute inverse dynamics\n    tau = robot.inverse_dynamics(joint_angles, joint_velocities, joint_accelerations)\n    print(f"Required joint torques: {tau}")\n    \n    # Compute forward dynamics\n    joint_torques = tau  # Use the same torques for verification\n    qddot = robot.forward_dynamics(joint_angles, joint_velocities, joint_torques)\n    print(f"Computed accelerations: {qddot}")\n    print(f"Input accelerations: {joint_accelerations}")\n    \n    print("\\nAdvanced humanoid kinematics and dynamics demonstration completed")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,a.jsx)(i.h2,{id:"simulation-demonstration",children:"Simulation Demonstration"}),"\n",(0,a.jsx)(i.p,{children:"This implementation demonstrates key concepts in humanoid kinematics and dynamics, including forward and inverse kinematics, Jacobian computation, and dynamic modeling. The code can be used in conjunction with simulation environments to plan and control complex humanoid robot movements."}),"\n",(0,a.jsx)(i.h2,{id:"hands-on-lab-humanoid-kinematics-and-dynamics-implementation",children:"Hands-On Lab: Humanoid Kinematics and Dynamics Implementation"}),"\n",(0,a.jsx)(i.p,{children:"In this lab, you'll implement and test advanced kinematics and dynamics for a humanoid robot:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Implement forward and inverse kinematics for a humanoid arm"}),"\n",(0,a.jsx)(i.li,{children:"Calculate and analyze the Jacobian matrix"}),"\n",(0,a.jsx)(i.li,{children:"Model the dynamics of the robot"}),"\n",(0,a.jsx)(i.li,{children:"Simulate the robot following a trajectory"}),"\n",(0,a.jsx)(i.li,{children:"Evaluate the performance and stability of your implementation"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"required-equipment",children:"Required Equipment:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"ROS 2 Humble environment"}),"\n",(0,a.jsx)(i.li,{children:"Python development environment"}),"\n",(0,a.jsx)(i.li,{children:"(Optional) Robot simulation environment (Gazebo, Isaac Sim)"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"instructions",children:"Instructions:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:["Create a new ROS 2 package: ",(0,a.jsx)(i.code,{children:"ros2 pkg create --build-type ament_python humanoid_kinematics_dynamics"})]}),"\n",(0,a.jsx)(i.li,{children:"Implement the HumanoidKinematicsDynamics class in your package"}),"\n",(0,a.jsx)(i.li,{children:"Create a node that demonstrates forward/inverse kinematics"}),"\n",(0,a.jsx)(i.li,{children:"Implement Jacobian-based control for the robot"}),"\n",(0,a.jsx)(i.li,{children:"Test with different trajectories and evaluate performance"}),"\n",(0,a.jsx)(i.li,{children:"Add dynamic modeling to your implementation"}),"\n",(0,a.jsx)(i.li,{children:"Compare the results of inverse and forward dynamics"}),"\n",(0,a.jsx)(i.li,{children:"Document your findings and any challenges encountered"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"common-pitfalls--debugging-notes",children:"Common Pitfalls & Debugging Notes"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Singularities"}),": Be aware of configurations where the Jacobian becomes singular"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Joint Limits"}),": Always check that your solutions respect physical joint limits"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Numerical Accuracy"}),": Small errors in kinematic calculations can accumulate"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Dynamics Parameters"}),": Accurate mass, inertia, and friction parameters are crucial for realistic simulation"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Computational Complexity"}),": Inverse dynamics can be computationally intensive; consider simplifications for real-time applications"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Coordinate Frames"}),": Ensure consistent use of coordinate frames and transformations"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"summary--key-terms",children:"Summary & Key Terms"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.strong,{children:"Key Terms:"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Forward Kinematics"}),": Calculating end-effector pose from joint angles"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Inverse Kinematics"}),": Calculating joint angles for desired end-effector pose"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Denavit-Hartenberg Parameters"}),": Convention for defining coordinate frames in kinematic chains"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Jacobian Matrix"}),": Relates joint velocities to Cartesian velocities"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Singularity"}),": Configuration where robot loses degrees of freedom"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Inertia Matrix"}),": Relates accelerations to applied forces in dynamics"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Coriolis Forces"}),": Velocity-dependent forces in rotating reference frames"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Lagrange-Euler Equations"}),": Mathematical formulation of robot dynamics"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"further-reading--citations",children:"Further Reading & Citations"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:'Spong, M. W., Hutchinson, S., & Vidyasagar, M. (2006). "Robot Modeling and Control." John Wiley & Sons.'}),"\n",(0,a.jsx)(i.li,{children:'Craig, J. J. (2005). "Introduction to Robotics: Mechanics and Control" (3rd ed.). Pearson Prentice Hall.'}),"\n",(0,a.jsx)(i.li,{children:'Featherstone, R. (2008). "Rigid Body Dynamics Algorithms." Springer.'}),"\n",(0,a.jsx)(i.li,{children:'Siciliano, B., & Khatib, O. (Eds.). (2016). "Springer Handbook of Robotics." Springer.'}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Explain the difference between forward and inverse kinematics and their respective challenges."}),"\n",(0,a.jsx)(i.li,{children:"What is the significance of the Jacobian matrix in robot control?"}),"\n",(0,a.jsx)(i.li,{children:"Describe the steps to calculate the forward kinematics using DH parameters."}),"\n",(0,a.jsx)(i.li,{children:"How do Coriolis and centrifugal forces affect humanoid robot dynamics?"}),"\n",(0,a.jsx)(i.li,{children:"What are the main challenges in solving inverse kinematics for redundant robots?"}),"\n"]}),"\n",(0,a.jsx)(i.hr,{}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Previous"}),": ",(0,a.jsx)(i.a,{href:"/Hackthon_SpecKitPlus/docs/humanoid-robotics/intro",children:"Introduction to Humanoid Robotics"}),(0,a.jsx)(i.br,{}),"\n",(0,a.jsx)(i.strong,{children:"Next"}),": ",(0,a.jsx)(i.a,{href:"/Hackthon_SpecKitPlus/docs/humanoid-robotics/locomotion",children:"Bipedal Locomotion and Walking Control"})]})]})}function m(n={}){const{wrapper:i}={...(0,o.R)(),...n.components};return i?(0,a.jsx)(i,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,i,e)=>{e.d(i,{R:()=>r,x:()=>s});var t=e(6540);const a={},o=t.createContext(a);function r(n){const i=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function s(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),t.createElement(o.Provider,{value:i},n.children)}}}]);