"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[403],{4022:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"humanoid-robotics/locomotion","title":"Bipedal Locomotion and Walking Control","description":"Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring precise control of multiple degrees of freedom while maintaining dynamic balance. Unlike wheeled or tracked robots, humanoid robots must manage their center of mass to prevent falling while walking, running, or performing other dynamic movements. This section explores the principles, algorithms, and control strategies for achieving stable bipedal locomotion.","source":"@site/docs/05-humanoid-robotics/locomotion.md","sourceDirName":"05-humanoid-robotics","slug":"/humanoid-robotics/locomotion","permalink":"/Hackthon_SpecKitPlus/docs/humanoid-robotics/locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/shaheryarshah/Hackthon_SpecKitPlus/edit/main/docs/docs/05-humanoid-robotics/locomotion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Kinematics and Dynamics","permalink":"/Hackthon_SpecKitPlus/docs/humanoid-robotics/kinematics"},"next":{"title":"Manipulation & Humanoid Hands","permalink":"/Hackthon_SpecKitPlus/docs/humanoid-robotics/manipulation"}}');var i=t(4848),r=t(8453);const l={},s="Bipedal Locomotion and Walking Control",a={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Walking Cycle Phases",id:"walking-cycle-phases",level:3},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Center of Mass (CoM) Control",id:"center-of-mass-com-control",level:3},{value:"Support Polygon",id:"support-polygon",level:3},{value:"Capture Point",id:"capture-point",level:3},{value:"Equations and Models",id:"equations-and-models",level:2},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"ZMP Calculation",id:"zmp-calculation",level:3},{value:"Capture Point Calculation",id:"capture-point-calculation",level:3},{value:"Preview Control for Walking",id:"preview-control-for-walking",level:3},{value:"Code Example: Bipedal Walking Controller",id:"code-example-bipedal-walking-controller",level:2},{value:"Simulation Demonstration",id:"simulation-demonstration",level:2},{value:"Hands-On Lab: Implementing Bipedal Walking",id:"hands-on-lab-implementing-bipedal-walking",level:2},{value:"Required Equipment:",id:"required-equipment",level:3},{value:"Instructions:",id:"instructions",level:3},{value:"Common Pitfalls &amp; Debugging Notes",id:"common-pitfalls--debugging-notes",level:2},{value:"Summary &amp; Key Terms",id:"summary--key-terms",level:2},{value:"Further Reading &amp; Citations",id:"further-reading--citations",level:2},{value:"Assessment Questions",id:"assessment-questions",level:2}];function p(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"bipedal-locomotion-and-walking-control",children:"Bipedal Locomotion and Walking Control"})}),"\n",(0,i.jsx)(n.p,{children:"Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring precise control of multiple degrees of freedom while maintaining dynamic balance. Unlike wheeled or tracked robots, humanoid robots must manage their center of mass to prevent falling while walking, running, or performing other dynamic movements. This section explores the principles, algorithms, and control strategies for achieving stable bipedal locomotion."}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"After completing this section, you should be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand the fundamental principles of bipedal locomotion"}),"\n",(0,i.jsx)(n.li,{children:"Analyze the phases of the human walking cycle"}),"\n",(0,i.jsx)(n.li,{children:"Implement ZMP-based walking pattern generation"}),"\n",(0,i.jsx)(n.li,{children:"Design controllers for bipedal balance and stepping"}),"\n",(0,i.jsx)(n.li,{children:"Evaluate the stability of walking gaits"}),"\n",(0,i.jsx)(n.li,{children:"Compare different walking control approaches for humanoid robots"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"walking-cycle-phases",children:"Walking Cycle Phases"}),"\n",(0,i.jsx)(n.p,{children:"Human walking consists of two main phases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stance Phase"}),": When the foot is in contact with the ground (60% of gait cycle)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swing Phase"}),": When the foot is off the ground moving forward (40% of gait cycle)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,i.jsx)(n.p,{children:"The ZMP is a critical concept for bipedal stability, representing the point where the net moment of the ground reaction forces is zero. For stable walking, the ZMP must remain within the support polygon formed by the feet."}),"\n",(0,i.jsx)(n.h3,{id:"center-of-mass-com-control",children:"Center of Mass (CoM) Control"}),"\n",(0,i.jsx)(n.p,{children:"Managing the CoM trajectory is essential for maintaining balance during walking. The CoM typically moves in a sinusoidal pattern in both lateral and vertical directions."}),"\n",(0,i.jsx)(n.h3,{id:"support-polygon",children:"Support Polygon"}),"\n",(0,i.jsx)(n.p,{children:"The support polygon is the convex hull of the ground contact points. For bipedal robots, this changes between single support (one foot on ground) and double support (both feet on ground) phases."}),"\n",(0,i.jsx)(n.h3,{id:"capture-point",children:"Capture Point"}),"\n",(0,i.jsx)(n.p,{children:"The capture point is where a biped would need to step to come to a complete stop, accounting for its current velocity and the dynamics of inverted pendulum motion."}),"\n",(0,i.jsx)(n.h2,{id:"equations-and-models",children:"Equations and Models"}),"\n",(0,i.jsx)(n.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,i.jsx)(n.p,{children:"The LIPM is commonly used for walking control:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u1e8d_com = \u03c9\xb2(x_com - x_zmp)\n\xff_com = \u03c9\xb2(y_com - y_zmp)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"\u03c9\xb2 = g/h"}),", with ",(0,i.jsx)(n.code,{children:"g"})," being gravity and ",(0,i.jsx)(n.code,{children:"h"})," the height of the COM"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(x_com, y_com)"})," is the center of mass position"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(x_zmp, y_zmp)"})," is the zero moment point position"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"zmp-calculation",children:"ZMP Calculation"}),"\n",(0,i.jsx)(n.p,{children:"The ZMP position is calculated from ground reaction forces:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"x_zmp = (\u03a3(F_z_i * x_i) - \u03a3(M_y_i)) / \u03a3(F_z_i)\ny_zmp = (\u03a3(F_z_i * y_i) + \u03a3(M_x_i)) / \u03a3(F_z_i)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"F_z_i"})," is the vertical force at contact point i"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"(x_i, y_i)"})," is the position of contact point i"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"M_x_i"}),", ",(0,i.jsx)(n.code,{children:"M_y_i"})," are the moments about the x and y axes at contact point i"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"capture-point-calculation",children:"Capture Point Calculation"}),"\n",(0,i.jsx)(n.p,{children:"The capture point is where a biped must step to stop:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"x_capture = x_com + \u1e8b_com/\u03c9\ny_capture = y_com + \u1e8f_com/\u03c9\n"})}),"\n",(0,i.jsx)(n.h3,{id:"preview-control-for-walking",children:"Preview Control for Walking"}),"\n",(0,i.jsx)(n.p,{children:"Preview control uses future reference trajectories to improve tracking:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u03c4 = K_p * e(t) + K_i * \u222be(t)dt + K_d * de(t)/dt + \u03a3(K_i * r(t+i))\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where the last term represents preview of future reference points."}),"\n",(0,i.jsx)(n.h2,{id:"code-example-bipedal-walking-controller",children:"Code Example: Bipedal Walking Controller"}),"\n",(0,i.jsx)(n.p,{children:"Here's an implementation of a ZMP-based walking controller for a humanoid robot:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\nimport math\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import solve_continuous_are\nimport matplotlib.pyplot as plt\n\n\nclass BipedalWalkingController:\n    """\n    ZMP-based walking controller for a humanoid robot\n    """\n    def __init__(self, com_height=0.8, dt=0.01, g=9.81):\n        """\n        Initialize the walking controller\n        \n        :param com_height: Height of the center of mass (m)\n        :param dt: Time step for control (s)\n        :param g: Gravitational acceleration (m/s\xb2)\n        """\n        self.com_height = com_height\n        self.dt = dt\n        self.g = g\n        self.omega = math.sqrt(self.g / self.com_height)  # Natural frequency\n        \n        # Walking parameters\n        self.step_length = 0.3  # Forward step distance (m)\n        self.step_width = 0.2   # Lateral step distance (m)\n        self.step_height = 0.05 # Maximum step height (m)\n        self.step_duration = 1.0  # Total step time (s)\n        self.double_support_ratio = 0.1  # Fraction of time in double support\n        \n        # Current state\n        self.com_x = 0.0\n        self.com_y = 0.0\n        self.com_z = com_height\n        self.com_x_dot = 0.0\n        self.com_y_dot = 0.0\n        self.com_z_dot = 0.0\n        \n        # Support polygon (initially left foot at origin)\n        self.left_foot = np.array([0.0, self.step_width/2.0, 0.0])\n        self.right_foot = np.array([0.0, -self.step_width/2.0, 0.0])\n        self.support_foot = \'left\'  # Which foot is currently supporting\n        \n        # Walking state\n        self.step_phase = 0.0  # Phase of current step (0.0 to 1.0)\n        self.swing_foot_trajectory = []\n        self.x_zmp_d = 0.0  # Desired ZMP position\n        self.y_zmp_d = 0.0\n        \n        # Walking pattern parameters\n        self.walk_forward = 0.0  # Forward walking speed (m/s)\n        self.walk_lateral = 0.0  # Lateral walking speed (m/s)\n        self.turn_rate = 0.0     # Turning speed (rad/s)\n        \n        # Initialize walking pattern\n        self.generate_next_step()\n    \n    def generate_next_step(self):\n        """\n        Generate the next step based on current walking parameters\n        """\n        # Calculate next foot position based on walking parameters\n        if self.support_foot == \'left\':\n            # Right foot will step forward and possibly laterally/rotationally\n            next_x = self.left_foot[0] + self.step_length * self.walk_forward\n            next_y = self.left_foot[1] - self.step_width * np.sign(self.right_foot[1])\n            \n            # Apply turning effect (simplified)\n            if self.turn_rate != 0:\n                # Simple turning model - rotate next step position\n                cos_turn = math.cos(self.turn_rate * self.step_duration / 2)\n                sin_turn = math.sin(self.turn_rate * self.step_duration / 2)\n                \n                # Rotate around support foot\n                rel_pos = np.array([next_x, next_y]) - self.left_foot[:2]\n                rotated_pos = np.array([\n                    rel_pos[0] * cos_turn - rel_pos[1] * sin_turn,\n                    rel_pos[0] * sin_turn + rel_pos[1] * cos_turn\n                ])\n                next_x, next_y = self.left_foot[:2] + rotated_pos\n                \n        else:  # Support foot is right\n            # Left foot will step\n            next_x = self.right_foot[0] + self.step_length * self.walk_forward\n            next_y = self.right_foot[1] - self.step_width * np.sign(self.left_foot[1])\n            \n            # Apply turning effect\n            if self.turn_rate != 0:\n                cos_turn = math.cos(self.turn_rate * self.step_duration / 2)\n                sin_turn = math.sin(self.turn_rate * self.step_duration / 2)\n                \n                # Rotate around support foot\n                rel_pos = np.array([next_x, next_y]) - self.right_foot[:2]\n                rotated_pos = np.array([\n                    rel_pos[0] * cos_turn - rel_pos[1] * sin_turn,\n                    rel_pos[0] * sin_turn + rel_pos[1] * cos_turn\n                ])\n                next_x, next_y = self.right_foot[:2] + rotated_pos\n        \n        # Generate swing foot trajectory\n        self.swing_foot_trajectory = self.generate_swing_trajectory(\n            self.get_swing_foot_position(), \n            [next_x, next_y, 0.0]\n        )\n        \n        # Update support polygon\n        if self.support_foot == \'left\':\n            self.right_foot = np.array([next_x, next_y, 0.0])\n        else:\n            self.left_foot = np.array([next_x, next_y, 0.0])\n    \n    def generate_swing_trajectory(self, start_pos, end_pos):\n        """\n        Generate trajectory for the swing foot using a 3rd order polynomial\n        """\n        trajectory = []\n        \n        # Start and end positions\n        x0, y0, z0 = start_pos\n        x1, y1, z1 = end_pos\n        \n        # Trajectory times\n        total_time = self.step_duration\n        double_support_time = self.step_duration * self.double_support_ratio\n        \n        # Generate 3rd order polynomial trajectory\n        for t in np.arange(0, total_time, self.dt):\n            # Use normalized time (0 to 1) for polynomial calculation\n            if t < double_support_time/2:\n                # Beginning double support phase\n                s = 0.0\n            elif t > total_time - double_support_time/2:\n                # End double support phase\n                s = 1.0\n            else:\n                # Single support phase\n                s = (t - double_support_time/2) / (total_time - double_support_time)\n                s = np.clip(s, 0, 1)\n            \n            # 3rd order polynomial: h(s) = 3s\xb2 - 2s\xb3\n            h1 = 3 * s**2 - 2 * s**3\n            dh1 = 6 * s - 6 * s**2  # Derivative\n            ddh1 = 6 - 12 * s       # Second derivative\n            \n            # Position interpolation\n            x = x0 + h1 * (x1 - x0)\n            y = y0 + h1 * (y1 - y0)\n            \n            # Height trajectory with arc\n            z = z0 + h1 * (z1 - z0) + 0.5 * (1 - math.cos(math.pi * s)) * self.step_height\n            \n            # Add to trajectory\n            trajectory.append([x, y, z])\n        \n        return trajectory\n    \n    def get_swing_foot_position(self):\n        """\n        Get the current position of the swing foot\n        """\n        if self.support_foot == \'left\':\n            return self.right_foot\n        else:\n            return self.left_foot\n    \n    def compute_com_trajectory(self, t, zmp_trajectory):\n        """\n        Compute CoM trajectory based on ZMP using inverted pendulum model\n        """\n        # For simplicity, we\'ll use a simplified approach\n        # In practice, this would involve solving the inverted pendulum equation\n        # or using a preview control approach\n        \n        # Calculate desired CoM position relative to ZMP\n        # Using LIPM: CoM should follow ZMP with specific dynamics\n        zmp_x, zmp_y = zmp_trajectory\n        \n        # Calculate desired CoM position to realize the ZMP\n        # Simplified approach: CoM follows ZMP with a small offset\n        desired_com_x = zmp_x\n        desired_com_y = zmp_y\n        \n        return desired_com_x, desired_com_y\n    \n    def update_balance(self, dt):\n        """\n        Update the balance control based on current state\n        """\n        # Determine support polygon based on current phase\n        if self.step_phase < self.double_support_ratio/2:\n            # Double support at beginning\n            support_polygon = self.calculate_support_polygon([self.left_foot, self.right_foot])\n        elif self.step_phase > 1.0 - self.double_support_ratio/2:\n            # Double support at end\n            support_polygon = self.calculate_support_polygon([self.left_foot, self.right_foot])\n        else:\n            # Single support on stance foot\n            stance_foot = self.left_foot if self.support_foot == \'left\' else self.right_foot\n            support_polygon = self.calculate_support_polygon([stance_foot])\n        \n        # Calculate desired ZMP based on walking pattern\n        self.x_zmp_d, self.y_zmp_d = self.calculate_desired_zmp(support_polygon)\n        \n        # Update CoM using LIPM dynamics\n        com_x_ddot = self.omega**2 * (self.com_x - self.x_zmp_d)\n        com_y_ddot = self.omega**2 * (self.com_y - self.y_zmp_d)\n        \n        # Update CoM state\n        self.com_x_dot += com_x_ddot * dt\n        self.com_y_dot += com_y_ddot * dt\n        \n        self.com_x += self.com_x_dot * dt\n        self.com_y += self.com_y_dot * dt\n        \n        # Simple CoM height control to maintain average height\n        height_error = self.com_height - self.com_z\n        self.com_z_dot += 0.1 * height_error * dt\n        self.com_z += self.com_z_dot * dt\n        \n        # Update step phase\n        self.step_phase += dt / self.step_duration\n        if self.step_phase >= 1.0:\n            # Step completed\n            self.step_phase = 0.0\n            # Switch support foot\n            self.support_foot = \'right\' if self.support_foot == \'left\' else \'left\'\n            # Generate next step\n            self.generate_next_step()\n    \n    def calculate_support_polygon(self, feet_positions):\n        """\n        Calculate support polygon from feet positions\n        """\n        # For now, return average of feet positions as simplified support polygon center\n        if len(feet_positions) > 0:\n            avg_pos = np.mean(feet_positions, axis=0)\n            return avg_pos[:2]  # Return x, y only\n        else:\n            return np.array([0.0, 0.0])\n    \n    def calculate_desired_zmp(self, support_polygon_center):\n        """\n        Calculate desired ZMP based on walking pattern and support polygon\n        """\n        # For stable walking, ZMP should be within support polygon\n        # For simplicity, we\'ll place ZMP at a stable position in the support polygon\n        # In practice, this would follow a more complex walking pattern\n        \n        # Calculate ZMP position with some margin from support polygon edges\n        margin = 0.05  # 5cm margin from edges\n        \n        # For now, place ZMP at the center of the support polygon\n        # with some stability margin\n        zmp_x = support_polygon_center[0]\n        zmp_y = support_polygon_center[1]\n        \n        # Add walking pattern influence\n        # This would be more complex in a real implementation\n        zmp_x += 0.5 * self.walk_forward * np.sin(self.step_phase * 2 * np.pi)\n        zmp_y += 0.3 * self.walk_lateral * np.sin(self.step_phase * 2 * np.pi)\n        \n        return zmp_x, zmp_y\n    \n    def set_walking_params(self, forward_speed, lateral_speed, turn_rate):\n        """\n        Set walking parameters for the robot\n        \n        :param forward_speed: Forward walking speed (m/s)\n        :param lateral_speed: Lateral walking speed (m/s)\n        :param turn_rate: Turning rate (rad/s)\n        """\n        self.walk_forward = forward_speed\n        self.walk_lateral = lateral_speed\n        self.turn_rate = turn_rate\n    \n    def step_simulation(self, dt=None):\n        """\n        Perform one simulation step\n        \n        :param dt: Time step (if None, use default dt)\n        :return: Current state [com_x, com_y, com_z, com_x_dot, com_y_dot, com_z_dot]\n        """\n        if dt is None:\n            dt = self.dt\n        \n        # Update balance control\n        self.update_balance(dt)\n        \n        # Return current CoM state\n        return [\n            self.com_x, self.com_y, self.com_z,\n            self.com_x_dot, self.com_y_dot, self.com_z_dot\n        ]\n\n\nclass WalkingPatternGenerator:\n    """\n    Advanced walking pattern generator using preview control\n    """\n    def __init__(self, com_height=0.8, dt=0.01, prediction_time=2.0):\n        """\n        Initialize the pattern generator\n        \n        :param com_height: Height of center of mass (m)\n        :param dt: Control time step (s)\n        :param prediction_time: Time horizon for preview control (s)\n        """\n        self.com_height = com_height\n        self.dt = dt\n        self.prediction_time = prediction_time\n        self.prediction_steps = int(prediction_time / dt)\n        self.g = 9.81\n        self.omega = math.sqrt(self.g / self.com_height)\n        \n        # Generate preview control gains\n        self.K_preview = self.calculate_preview_gains()\n    \n    def calculate_preview_gains(self):\n        """\n        Calculate preview control gains using LQR method\n        """\n        # State: [x, x_dot] (simplified single-axis model)\n        A = np.array([[0, 1], [self.omega**2, 0]])\n        B = np.array([[0], [-self.omega**2]])\n        C = np.array([[1, 0]])  # Output is position\n        \n        # LQR weights\n        Q = np.array([[1, 0], [0, 0.1]])  # State cost\n        R = np.array([[0.1]])             # Control effort cost\n        \n        # Discrete-time system\n        I = np.eye(2)\n        Ad = I + self.dt * A\n        Bd = self.dt * B\n        \n        # Solve DARE to get LQR gain\n        # For preview control, we also need the preview gain matrix\n        # This is a simplified calculation\n        P = np.array([[0.3162, 0], [0, 1.7783]])  # Pre-computed solution for example\n        \n        K_lqr = np.linalg.inv(R + Bd.T @ P @ Bd) @ (Bd.T @ P @ Ad)\n        \n        # For preview control, compute additional gains for future reference tracking\n        # This is a simplified approximation\n        K_preview = []\n        for i in range(self.prediction_steps):\n            k = (self.omega * np.exp(-self.omega * i * self.dt) * self.dt)\n            K_preview.append(k)\n        \n        return np.array(K_preview)\n    \n    def generate_walking_pattern(self, zmp_reference, initial_state):\n        """\n        Generate CoM trajectory using preview control\n        \n        :param zmp_reference: Reference ZMP trajectory\n        :param initial_state: Initial [com_x, com_x_dot] state\n        :return: CoM trajectory that realizes the ZMP reference\n        """\n        # This is a simplified implementation of preview control\n        # In a full implementation, this would use the calculated gains\n        # to track a reference ZMP trajectory\n        \n        x_com = initial_state[0]\n        x_com_dot = initial_state[1]\n        \n        com_trajectory = []\n        zmp_trajectory = []\n        \n        for i, zmp_ref in enumerate(zmp_reference):\n            # In preview control, future reference values influence current control\n            # For simplicity, compute using LIPM dynamics with a feedback controller\n            x_com_ddot = self.omega**2 * (x_com - zmp_ref)\n            \n            # Simple PD control with preview (simplified)\n            feedback_control = -1.0 * (x_com - zmp_ref) - 0.7 * x_com_dot\n            \n            # Update state\n            x_com_dot += self.dt * (self.omega**2 * (x_com - zmp_ref) + feedback_control)\n            x_com += self.dt * x_com_dot\n            \n            com_trajectory.append([x_com, x_com_dot])\n            zmp_trajectory.append(zmp_ref)\n        \n        return np.array(com_trajectory), np.array(zmp_trajectory)\n\n\ndef main():\n    # Example usage of the bipedal walking controller\n    print("Bipedal Walking Controller Example")\n    \n    # Initialize the walking controller\n    walker = BipedalWalkingController(com_height=0.8, dt=0.01)\n    \n    # Define walking parameters\n    walker.set_walking_params(forward_speed=0.3, lateral_speed=0.0, turn_rate=0.0)\n    \n    # Simulate walking for a few seconds\n    simulation_time = 5.0  # seconds\n    steps = int(simulation_time / walker.dt)\n    \n    # Storage for recording the simulation\n    com_history = []\n    zmp_history = []\n    time_history = []\n    \n    print(f"Simulating bipedal walking for {simulation_time} seconds...")\n    \n    for i in range(steps):\n        # Perform simulation step\n        state = walker.step_simulation()\n        com_pos = state[:3]\n        time_history.append(i * walker.dt)\n        \n        # Record CoM and ZMP positions\n        com_history.append(com_pos.copy())\n        zmp_history.append([walker.x_zmp_d, walker.y_zmp_d])\n        \n        # Print status every second\n        if i % int(1.0 / walker.dt) == 0:\n            print(f"Time: {i * walker.dt:.2f}s, CoM: [{com_pos[0]:.3f}, {com_pos[1]:.3f}, {com_pos[2]:.3f}], "\n                  f"Support: {walker.support_foot}, Phase: {walker.step_phase:.2f}")\n    \n    # Convert to numpy arrays for analysis\n    com_history = np.array(com_history)\n    zmp_history = np.array(zmp_history)\n    \n    # Print final statistics\n    avg_com_x = np.mean(com_history[:, 0])\n    avg_com_y = np.mean(com_history[:, 1])\n    avg_com_z = np.mean(com_history[:, 2])\n    \n    print(f"\\nWalking statistics:")\n    print(f"Average CoM position: [{avg_com_x:.3f}, {avg_com_y:.3f}, {avg_com_z:.3f}]")\n    print(f"CoM position range:")\n    print(f"  X: [{np.min(com_history[:, 0]):.3f}, {np.max(com_history[:, 0]):.3f}]")\n    print(f"  Y: [{np.min(com_history[:, 1]):.3f}, {np.max(com_history[:, 1]):.3f}]")\n    print(f"  Z: [{np.min(com_history[:, 2]):.3f}, {np.max(com_history[:, 2]):.3f}]")\n    \n    # Test the walking pattern generator\n    print(f"\\nTesting walking pattern generator...")\n    \n    # Create a simple ZMP reference trajectory (moving forward)\n    pattern_gen = WalkingPatternGenerator(com_height=0.8, dt=0.01)\n    zmp_ref = np.linspace(0.0, 1.0, int(2.0 / 0.01))  # Move ZMP forward over 2 seconds\n    \n    # Generate CoM trajectory\n    initial_state = [0.0, 0.0]  # [initial_pos, initial_vel]\n    com_traj, zmp_traj = pattern_gen.generate_walking_pattern(zmp_ref, initial_state)\n    \n    print(f"Generated {len(com_traj)} trajectory points")\n    print(f"CoM moved from {com_traj[0, 0]:.3f} to {com_traj[-1, 0]:.3f}")\n    \n    print("\\nBipedal walking controller demonstration completed")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"simulation-demonstration",children:"Simulation Demonstration"}),"\n",(0,i.jsx)(n.p,{children:"This implementation demonstrates the core concepts of bipedal locomotion, including ZMP-based control, walking pattern generation, and balance maintenance. The controller can be integrated with simulation environments like Gazebo or Isaac Sim to test walking behaviors on virtual humanoid robots."}),"\n",(0,i.jsx)(n.h2,{id:"hands-on-lab-implementing-bipedal-walking",children:"Hands-On Lab: Implementing Bipedal Walking"}),"\n",(0,i.jsx)(n.p,{children:"In this lab, you'll implement and test a complete bipedal walking controller:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement ZMP-based walking control"}),"\n",(0,i.jsx)(n.li,{children:"Generate walking patterns for forward, lateral, and turning motions"}),"\n",(0,i.jsx)(n.li,{children:"Test balance control under disturbances"}),"\n",(0,i.jsx)(n.li,{children:"Analyze the stability of your walking controller"}),"\n",(0,i.jsx)(n.li,{children:"Optimize the walking controller parameters"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"required-equipment",children:"Required Equipment:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ROS 2 Humble environment"}),"\n",(0,i.jsx)(n.li,{children:"Gazebo or Isaac Sim"}),"\n",(0,i.jsx)(n.li,{children:"Humanoid robot model (e.g., Atlas, THORMANG3, or custom model)"}),"\n",(0,i.jsx)(n.li,{children:"Python development environment"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"instructions",children:"Instructions:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Create a new ROS 2 package: ",(0,i.jsx)(n.code,{children:"ros2 pkg create --build-type ament_python bipedal_walking_controller"})]}),"\n",(0,i.jsx)(n.li,{children:"Implement the BipedalWalkingController class in your package"}),"\n",(0,i.jsx)(n.li,{children:"Test the controller with different walking speeds and directions"}),"\n",(0,i.jsx)(n.li,{children:"Implement a simple state machine for walking control"}),"\n",(0,i.jsx)(n.li,{children:"Add disturbance rejection capabilities"}),"\n",(0,i.jsx)(n.li,{children:"Evaluate the stability margins of your controller"}),"\n",(0,i.jsx)(n.li,{children:"Tune the controller parameters for optimal performance"}),"\n",(0,i.jsx)(n.li,{children:"Document the walking patterns and stability characteristics of your controller"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-pitfalls--debugging-notes",children:"Common Pitfalls & Debugging Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ZMP Stability"}),": Ensure the ZMP remains within the support polygon at all times"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CoM Trajectory"}),": The CoM trajectory should be smooth to avoid excessive accelerations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Step Timing"}),": Properly manage the transition between single and double support phases"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disturbance Handling"}),": Implement robust control to handle external disturbances"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Foot Placement"}),": Proper foot placement is critical for balance recovery"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simulation Accuracy"}),": Realistic simulation models are essential for valid results"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter Tuning"}),": Walking controllers often require careful parameter tuning"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary--key-terms",children:"Summary & Key Terms"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Terms:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bipedal Locomotion"}),": Walking on two legs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero Moment Point (ZMP)"}),": Point where net moment of ground reaction forces is zero"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stance Phase"}),": When the foot is in contact with ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swing Phase"}),": When the foot is off ground moving forward"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Linear Inverted Pendulum Model (LIPM)"}),": Simplified model for walking dynamics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Support Polygon"}),": Convex hull of ground contact points"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Capture Point"}),": Point where robot must step to come to a complete stop"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Preview Control"}),": Control method using future reference trajectories"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Support"}),": When only one foot is in contact with ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Double Support"}),": When both feet are in contact with ground"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"further-reading--citations",children:"Further Reading & Citations"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:'Kajita, S., et al. (2003). "Biped walking pattern generation by using preview control of zero-moment point." IEEE International Conference on Robotics and Automation.'}),"\n",(0,i.jsx)(n.li,{children:'Pratt, J., & Tedrake, R. (2006). "On polynomial-based temporal discretization for impedance control." International Journal of Humanoid Robotics.'}),"\n",(0,i.jsx)(n.li,{children:'Takenaka, T., et al. (2009). "Real time motion generation and control for biped robot\u20141st report: Walking pattern generation." IEEE-RAS International Conference on Humanoid Robots.'}),"\n",(0,i.jsx)(n.li,{children:'Shafii, N., et al. (2011). "Fast pattern synthesis by using ZMP preview controller for a biped robot standing on a narrow support area." IEEE-RAS International Conference on Humanoid Robots.'}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Explain the concept of Zero Moment Point (ZMP) and its role in bipedal stability."}),"\n",(0,i.jsx)(n.li,{children:"What are the main phases of the human walking cycle and their characteristics?"}),"\n",(0,i.jsx)(n.li,{children:"Describe the Linear Inverted Pendulum Model (LIPM) and its application to walking control."}),"\n",(0,i.jsx)(n.li,{children:"How does preview control improve walking pattern generation?"}),"\n",(0,i.jsx)(n.li,{children:"What are the key challenges in implementing stable bipedal locomotion?"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Previous"}),": ",(0,i.jsx)(n.a,{href:"/Hackthon_SpecKitPlus/docs/humanoid-robotics/kinematics",children:"Humanoid Kinematics and Dynamics"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Next"}),": ",(0,i.jsx)(n.a,{href:"/Hackthon_SpecKitPlus/docs/vla-robotics/intro",children:"Vision-Language-Action Robotics"})]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var o=t(6540);const i={},r=o.createContext(i);function l(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);