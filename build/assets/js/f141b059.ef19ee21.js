"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[241],{4594:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"capstone/system-design","title":"System Design and Implementation","description":"The system design of our autonomous humanoid robot represents the culmination of all concepts covered in this textbook. This chapter details the architectural decisions, implementation strategies, and engineering considerations that went into creating a complete, functional robotic system. The design follows modern robotics principles while integrating Physical AI, ROS 2, simulation, NVIDIA Isaac, Vision-Language-Action capabilities, and humanoid robotics fundamentals.","source":"@site/docs/07-capstone/system-design.md","sourceDirName":"07-capstone","slug":"/capstone/system-design","permalink":"/Hackthon_SpecKitPlus/docs/capstone/system-design","draft":false,"unlisted":false,"editUrl":"https://github.com/shaheryarshah/Hackthon_SpecKitPlus/edit/main/docs/docs/07-capstone/system-design.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Capstone Project: Autonomous Humanoid Robot","permalink":"/Hackthon_SpecKitPlus/docs/capstone/intro"},"next":{"title":"Appendix A: Hardware Requirements and Lab Options","permalink":"/Hackthon_SpecKitPlus/docs/appendices/hardware"}}');var i=s(4848),a=s(8453);const o={},r="System Design and Implementation",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Modular Architecture",id:"modular-architecture",level:3},{value:"Real-Time Considerations",id:"real-time-considerations",level:3},{value:"Safety-First Design",id:"safety-first-design",level:3},{value:"Scalability Principles",id:"scalability-principles",level:3},{value:"Equations and Models",id:"equations-and-models",level:2},{value:"System Architecture Model",id:"system-architecture-model",level:3},{value:"System Reliability Model",id:"system-reliability-model",level:3},{value:"Performance Bottleneck Analysis",id:"performance-bottleneck-analysis",level:3},{value:"Code Example: System Architecture Implementation",id:"code-example-system-architecture-implementation",level:2},{value:"Simulation Demonstration",id:"simulation-demonstration",level:2},{value:"Hands-On Lab: System Architecture Implementation",id:"hands-on-lab-system-architecture-implementation",level:2},{value:"Required Equipment:",id:"required-equipment",level:3},{value:"Instructions:",id:"instructions",level:3},{value:"Common Pitfalls &amp; Debugging Notes",id:"common-pitfalls--debugging-notes",level:2},{value:"Summary &amp; Key Terms",id:"summary--key-terms",level:2},{value:"Further Reading &amp; Citations",id:"further-reading--citations",level:2},{value:"Assessment Questions",id:"assessment-questions",level:2}];function m(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"system-design-and-implementation",children:"System Design and Implementation"})}),"\n",(0,i.jsx)(n.p,{children:"The system design of our autonomous humanoid robot represents the culmination of all concepts covered in this textbook. This chapter details the architectural decisions, implementation strategies, and engineering considerations that went into creating a complete, functional robotic system. The design follows modern robotics principles while integrating Physical AI, ROS 2, simulation, NVIDIA Isaac, Vision-Language-Action capabilities, and humanoid robotics fundamentals."}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"After studying this chapter, you should be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand the architectural design of complex autonomous robotic systems"}),"\n",(0,i.jsx)(n.li,{children:"Apply design patterns and principles to robotic system development"}),"\n",(0,i.jsx)(n.li,{children:"Implement modular systems with well-defined interfaces"}),"\n",(0,i.jsx)(n.li,{children:"Design safety mechanisms and fail-safe procedures"}),"\n",(0,i.jsx)(n.li,{children:"Create scalable architectures that can accommodate future enhancements"}),"\n",(0,i.jsx)(n.li,{children:"Evaluate design decisions for their impact on system performance and safety"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"modular-architecture",children:"Modular Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The system is designed with modularity in mind:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decoupled Components"}),": Each module can function independently"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Well-Defined Interfaces"}),": Clear input/output specifications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Replaceable Components"}),": Modules can be swapped without affecting others"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testable Units"}),": Individual modules can be validated in isolation"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"real-time-considerations",children:"Real-Time Considerations"}),"\n",(0,i.jsx)(n.p,{children:"The system design accounts for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hard Real-Time Requirements"}),": Safety-critical actions with strict timing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Soft Real-Time Requirements"}),": Performance-critical but flexible timing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Efficient use of computational resources"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scheduling"}),": Prioritizing critical tasks appropriately"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"safety-first-design",children:"Safety-First Design"}),"\n",(0,i.jsx)(n.p,{children:"Critical safety aspects include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fail-Safe Mechanisms"}),": Default safe states when systems fail"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Redundancy"}),": Multiple pathways for critical functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitoring"}),": Continuous checks on system health"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Emergency Procedures"}),": Quick response to dangerous situations"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"scalability-principles",children:"Scalability Principles"}),"\n",(0,i.jsx)(n.p,{children:"The design supports:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Future Expansion"}),": Adding new capabilities without redesign"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Scaling"}),": Handling increased complexity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Platform Portability"}),": Adapting to different robot platforms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-Robot Coordination"}),": Extending to multiple robots"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"equations-and-models",children:"Equations and Models"}),"\n",(0,i.jsx)(n.h3,{id:"system-architecture-model",children:"System Architecture Model"}),"\n",(0,i.jsx)(n.p,{children:"The system architecture can be modeled as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"S = M\u2081 \xd7 M\u2082 \xd7 ... \xd7 M\u2099 \u2192 R\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"S"})," is the system input (sensors, commands)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"M\u1d62"})," are the system modules"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"R"})," is the system output (actions, responses)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"system-reliability-model",children:"System Reliability Model"}),"\n",(0,i.jsx)(n.p,{children:"The overall system reliability:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"R_system = R_voice \xd7 R_perception \xd7 R_planning \xd7 R_execution \xd7 R_safety\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where each reliability factor represents the probability that the respective module functions correctly."}),"\n",(0,i.jsx)(n.h3,{id:"performance-bottleneck-analysis",children:"Performance Bottleneck Analysis"}),"\n",(0,i.jsx)(n.p,{children:"Identifying system bottlenecks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"T_total = T_voice + T_perception + T_planning + T_execution + T_communication\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"T_total"})," must be less than the system's real-time constraints."]}),"\n",(0,i.jsx)(n.h2,{id:"code-example-system-architecture-implementation",children:"Code Example: System Architecture Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Here's an implementation of the complete system architecture with design patterns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport threading\nimport queue\nimport time\nfrom dataclasses import dataclass\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import Dict, Any, List, Optional, Callable\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n# Logging setup\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass ComponentStatus(Enum):\n    """Status of system components"""\n    INITIALIZING = "initializing"\n    READY = "ready"\n    PROCESSING = "processing"\n    ERROR = "error"\n    SHUTDOWN = "shutdown"\n\n\n@dataclass\nclass SystemMessage:\n    """Message passed between system components"""\n    message_type: str\n    content: Any\n    timestamp: float = 0.0\n    source: str = ""\n    priority: int = 5  # 1-10 priority level\n    \n    def __post_init__(self):\n        if self.timestamp == 0.0:\n            self.timestamp = time.time()\n\n\nclass SystemBus:\n    """Central message bus for component communication"""\n    \n    def __init__(self):\n        self.subscribers: Dict[str, List[Callable]] = {}\n        self.message_queue = queue.Queue()\n        self.running = False\n        self.executor = ThreadPoolExecutor(max_workers=10)\n    \n    def subscribe(self, message_type: str, callback: Callable):\n        """Subscribe to specific message types"""\n        if message_type not in self.subscribers:\n            self.subscribers[message_type] = []\n        self.subscribers[message_type].append(callback)\n    \n    def publish(self, message: SystemMessage):\n        """Publish a message to all subscribers"""\n        if message.message_type in self.subscribers:\n            for callback in self.subscribers[message.message_type]:\n                # Use executor to run callbacks in separate threads\n                self.executor.submit(callback, message)\n    \n    def start(self):\n        """Start the message bus"""\n        self.running = True\n        logger.info("System bus started")\n    \n    def stop(self):\n        """Stop the message bus"""\n        self.running = False\n        self.executor.shutdown(wait=True)\n        logger.info("System bus stopped")\n\n\nclass SystemComponent(ABC):\n    """Abstract base class for system components"""\n    \n    def __init__(self, name: str, system_bus: SystemBus):\n        self.name = name\n        self.system_bus = system_bus\n        self.status = ComponentStatus.INITIALIZING\n        self.start_time = 0.0\n        self.error_count = 0\n        self.health_score = 100.0  # 0-100 scale\n    \n    @abstractmethod\n    async def initialize(self):\n        """Initialize the component"""\n        pass\n    \n    @abstractmethod\n    async def process(self, message: SystemMessage):\n        """Process a message"""\n        pass\n    \n    @abstractmethod\n    def get_status(self) -> ComponentStatus:\n        """Get component status"""\n        return self.status\n    \n    def report_error(self, error: Exception):\n        """Report an error and update health score"""\n        self.error_count += 1\n        self.health_score = max(0, self.health_score - 10)\n        logger.error(f"Component {self.name} error: {error}")\n    \n    def update_health(self, performance_score: float):\n        """Update health score based on performance"""\n        self.health_score = min(100, 0.7 * self.health_score + 0.3 * performance_score)\n\n\nclass SafetyManager(SystemComponent):\n    """Manages safety monitoring and emergency procedures"""\n    \n    def __init__(self, name: str, system_bus: SystemBus):\n        super().__init__(name, system_bus)\n        self.safety_constraints = {\n            "max_velocity": 1.0,  # m/s\n            "collision_distance": 0.5,  # meters\n            "joint_limits": [-3.14, 3.14],  # radians\n            "battery_threshold": 10.0  # percentage\n        }\n        self.emergency_active = False\n        self.safety_violations = []\n        self.robot_state = {\n            "position": [0.0, 0.0, 0.0],\n            "velocity": [0.0, 0.0, 0.0],\n            "battery_level": 100.0,\n            "gripper_state": "open"\n        }\n    \n    async def initialize(self):\n        """Initialize the safety manager"""\n        self.system_bus.subscribe("robot_state", self.handle_robot_state)\n        self.system_bus.subscribe("emergency_stop", self.handle_emergency_stop)\n        self.system_bus.subscribe("action_request", self.handle_action_request)\n        self.status = ComponentStatus.READY\n        logger.info(f"{self.name} initialized")\n    \n    async def process(self, message: SystemMessage):\n        """Process safety-related messages"""\n        try:\n            if message.message_type == "action_request":\n                # Check if action is safe\n                is_safe = self._check_action_safety(message.content)\n                if not is_safe:\n                    logger.warning(f"Action blocked by safety manager: {message.content}")\n                    self.system_bus.publish(SystemMessage(\n                        "action_blocked",\n                        {"reason": "safety_violation", "action": message.content},\n                        source=self.name\n                    ))\n                    return False\n            elif message.message_type == "robot_state":\n                # Update robot state for safety monitoring\n                self.robot_state.update(message.content)\n            \n            return True\n        except Exception as e:\n            self.report_error(e)\n            return False\n    \n    def _check_action_safety(self, action: Dict[str, Any]) -> bool:\n        """Check if an action is safe to execute"""\n        # Check velocity constraints\n        if action.get("type") == "move" and action.get("velocity", 0) > self.safety_constraints["max_velocity"]:\n            self.safety_violations.append(f"Velocity limit exceeded: {action[\'velocity\']}")\n            return False\n        \n        # Check collision constraints\n        if action.get("type") == "navigate" and action.get("target"):\n            # Simulate distance check\n            target = action["target"]\n            current_pos = self.robot_state["position"]\n            distance = sum((target[i] - current_pos[i])**2 for i in range(2))**0.5\n            \n            if distance < self.safety_constraints["collision_distance"]:\n                self.safety_violations.append(f"Collision risk: target too close: {distance}")\n                return False\n        \n        # Check battery level\n        if self.robot_state.get("battery_level", 100) < self.safety_constraints["battery_threshold"]:\n            self.safety_violations.append("Battery level too low")\n            return False\n        \n        return True\n    \n    def handle_robot_state(self, message: SystemMessage):\n        """Handle robot state updates"""\n        if message.message_type == "robot_state":\n            self.robot_state.update(message.content)\n    \n    def handle_emergency_stop(self, message: SystemMessage):\n        """Handle emergency stop request"""\n        if message.message_type == "emergency_stop":\n            self.emergency_active = True\n            logger.warning("EMERGENCY STOP ACTIVATED")\n    \n    def handle_action_request(self, message: SystemMessage):\n        """Handle action request with safety checks"""\n        if message.message_type == "action_request":\n            is_safe = self._check_action_safety(message.content)\n            if not is_safe:\n                self.system_bus.publish(SystemMessage(\n                    "safety_violation",\n                    {"violations": self.safety_violations[-1:]},  # Last violation\n                    source=self.name\n                ))\n    \n    def trigger_emergency_stop(self):\n        """Trigger emergency stop"""\n        self.emergency_active = True\n        self.system_bus.publish(SystemMessage(\n            "emergency_stop", \n            {"source": self.name}, \n            source=self.name\n        ))\n    \n    def get_status(self) -> ComponentStatus:\n        """Get safety manager status"""\n        if self.emergency_active:\n            return ComponentStatus.ERROR\n        return self.status\n\n\nclass VoiceProcessingComponent(SystemComponent):\n    """Component for processing voice commands"""\n    \n    def __init__(self, name: str, system_bus: SystemBus):\n        super().__init__(name, system_bus)\n        self.command_history = []\n        self.active_listening = False\n    \n    async def initialize(self):\n        """Initialize voice processing"""\n        self.system_bus.subscribe("voice_input", self.handle_voice_input)\n        self.status = ComponentStatus.READY\n        logger.info(f"{self.name} initialized")\n    \n    async def process(self, message: SystemMessage):\n        """Process voice-related messages"""\n        try:\n            if message.message_type == "voice_input":\n                # Simulate voice processing\n                text = self._process_audio(message.content)\n                confidence = self._estimate_confidence(text)\n                \n                if confidence > 0.7:  # Confidence threshold\n                    parsed_command = self._parse_command(text)\n                    self.system_bus.publish(SystemMessage(\n                        "command_parsed",\n                        {\n                            "text": text,\n                            "confidence": confidence,\n                            "parsed": parsed_command,\n                            "timestamp": message.timestamp\n                        },\n                        source=self.name\n                    ))\n                else:\n                    logger.warning(f"Low confidence voice command: {confidence}")\n                \n                return True\n            return False\n        except Exception as e:\n            self.report_error(e)\n            return False\n    \n    def _process_audio(self, audio_data: bytes) -> str:\n        """Process audio data (simulated)"""\n        # In a real system, this would use ASR like Whisper\n        # For simulation, return a fixed command\n        import random\n        commands = [\n            "Go to the kitchen and bring me a cup",\n            "Move to the table and grasp the red object",\n            "Navigate to the bedroom",\n            "Pick up the blue bottle"\n        ]\n        return random.choice(commands) if random.random() > 0.3 else "Unknown command"\n    \n    def _estimate_confidence(self, text: str) -> float:\n        """Estimate confidence in transcription"""\n        if text == "Unknown command":\n            return 0.3\n        return 0.8 + (len(text) % 5) * 0.05  # Simulate confidence based on text length\n    \n    def _parse_command(self, text: str) -> Dict[str, Any]:\n        """Parse the command into structured format"""\n        # Simple parsing for demonstration\n        tokens = text.lower().split()\n        entities = []\n        actions = []\n        \n        for token in tokens:\n            if token in ["kitchen", "bedroom", "table", "living room"]:\n                entities.append({"type": "location", "value": token})\n            elif token in ["cup", "bottle", "box", "object"]:\n                entities.append({"type": "object", "value": token})\n            elif token in ["go", "move", "navigate", "pick", "grasp"]:\n                actions.append(token)\n        \n        return {\n            "original_text": text,\n            "actions": actions,\n            "entities": entities,\n            "intent": self._determine_intent(text)\n        }\n    \n    def _determine_intent(self, text: str) -> str:\n        """Determine the intent of the command"""\n        text_lower = text.lower()\n        if any(word in text_lower for word in ["go", "navigate", "move"]):\n            return "navigation"\n        elif any(word in text_lower for word in ["pick", "grasp", "take"]):\n            return "manipulation"\n        else:\n            return "unknown"\n    \n    def handle_voice_input(self, message: SystemMessage):\n        """Handle voice input directly"""\n        if message.message_type == "voice_input":\n            asyncio.create_task(self.process(message))\n\n\nclass PerceptionComponent(SystemComponent):\n    """Component for environment perception"""\n    \n    def __init__(self, name: str, system_bus: SystemBus):\n        super().__init__(name, system_bus)\n        self.objects = {}\n        self.spatial_map = {}\n        self.last_update = 0.0\n    \n    async def initialize(self):\n        """Initialize perception component"""\n        self.system_bus.subscribe("request_perception", self.handle_perception_request)\n        self.status = ComponentStatus.READY\n        logger.info(f"{self.name} initialized")\n    \n    async def process(self, message: SystemMessage):\n        """Process perception-related messages"""\n        try:\n            if message.message_type == "request_perception":\n                perception_data = await self._update_perception()\n                self.system_bus.publish(SystemMessage(\n                    "perception_update",\n                    perception_data,\n                    source=self.name\n                ))\n                return True\n            return False\n        except Exception as e:\n            self.report_error(e)\n            return False\n    \n    async def _update_perception(self) -> Dict[str, Any]:\n        """Update perception data (simulated)"""\n        await asyncio.sleep(0.1)  # Simulate processing time\n        \n        # Simulate detecting objects\n        new_objects = {\n            "red_cup": {"position": [1.0, 0.5, 0.0], "type": "cup", "color": "red", "confidence": 0.9},\n            "blue_bottle": {"position": [1.5, 1.0, 0.0], "type": "bottle", "color": "blue", "confidence": 0.85},\n            "table": {"position": [0.0, 1.0, 0.0], "type": "furniture", "confidence": 0.95}\n        }\n        \n        self.objects.update(new_objects)\n        self.last_update = time.time()\n        \n        return {\n            "objects": new_objects,\n            "timestamp": self.last_update,\n            "update_duration": 0.1  # Simulated\n        }\n    \n    def handle_perception_request(self, message: SystemMessage):\n        """Handle perception update request"""\n        if message.message_type == "request_perception":\n            asyncio.create_task(self.process(message))\n\n\nclass PlanningComponent(SystemComponent):\n    """Component for task planning"""\n    \n    def __init__(self, name: str, system_bus: SystemBus):\n        super().__init__(name, system_bus)\n        self.known_locations = {\n            "kitchen": [2.0, 0.0, 0.0],\n            "bedroom": [-1.0, 1.0, 0.0],\n            "living_room": [0.0, 2.0, 0.0],\n            "table": [0.5, 1.0, 0.0]\n        }\n        self.current_plan = None\n        self.plan_history = []\n    \n    async def initialize(self):\n        """Initialize planning component"""\n        self.system_bus.subscribe("command_parsed", self.handle_parsed_command)\n        self.system_bus.subscribe("request_plan", self.handle_plan_request)\n        self.status = ComponentStatus.READY\n        logger.info(f"{self.name} initialized")\n    \n    async def process(self, message: SystemMessage):\n        """Process planning-related messages"""\n        try:\n            if message.message_type == "command_parsed":\n                # Generate plan based on parsed command\n                plan = self._generate_plan(message.content)\n                self.current_plan = plan\n                self.plan_history.append(plan)\n                \n                self.system_bus.publish(SystemMessage(\n                    "plan_generated",\n                    plan,\n                    source=self.name\n                ))\n                \n                return True\n            elif message.message_type == "request_plan":\n                if self.current_plan:\n                    self.system_bus.publish(SystemMessage(\n                        "current_plan",\n                        self.current_plan,\n                        source=self.name\n                    ))\n                return True\n            \n            return False\n        except Exception as e:\n            self.report_error(e)\n            return False\n    \n    def _generate_plan(self, command_data: Dict[str, Any]) -> Dict[str, Any]:\n        """Generate a plan from parsed command"""\n        text = command_data["text"]\n        entities = command_data["parsed"]["entities"]\n        intent = command_data["parsed"]["intent"]\n        \n        plan_steps = []\n        \n        # Simple planning for demonstration\n        if intent == "navigation":\n            for entity in entities:\n                if entity["type"] == "location" and entity["value"] in self.known_locations:\n                    target_pos = self.known_locations[entity["value"]]\n                    plan_steps.append({\n                        "action": "navigate",\n                        "target": target_pos,\n                        "description": f"Navigate to {entity[\'value\']}"\n                    })\n        \n        elif intent == "manipulation":\n            for entity in entities:\n                if entity["type"] == "object":\n                    plan_steps.append({\n                        "action": "detect",\n                        "target": entity["value"],\n                        "description": f"Detect {entity[\'value\']}"\n                    })\n                    plan_steps.append({\n                        "action": "move_to",\n                        "target": entity["value"],\n                        "description": f"Move to {entity[\'value\']}"\n                    })\n                    plan_steps.append({\n                        "action": "grasp",\n                        "target": entity["value"],\n                        "description": f"Grasp {entity[\'value\']}"\n                    })\n        \n        return {\n            "goal": text,\n            "steps": plan_steps,\n            "generated_at": time.time(),\n            "confidence": command_data["confidence"]\n        }\n    \n    def handle_parsed_command(self, message: SystemMessage):\n        """Handle parsed command for planning"""\n        if message.message_type == "command_parsed":\n            asyncio.create_task(self.process(message))\n    \n    def handle_plan_request(self, message: SystemMessage):\n        """Handle plan request"""\n        if message.message_type == "request_plan":\n            asyncio.create_task(self.process(message))\n\n\nclass ExecutionComponent(SystemComponent):\n    """Component for action execution"""\n    \n    def __init__(self, name: str, system_bus: SystemBus):\n        super().__init__(name, system_bus)\n        self.robot_position = [0.0, 0.0, 0.0]\n        self.gripper_state = "open"\n        self.current_action = None\n        self.action_queue = queue.Queue()\n        self.executor_running = False\n    \n    async def initialize(self):\n        """Initialize execution component"""\n        self.system_bus.subscribe("plan_generated", self.handle_plan_generated)\n        self.system_bus.subscribe("execute_action", self.handle_execute_action)\n        self.executor_running = True\n        self.status = ComponentStatus.READY\n        logger.info(f"{self.name} initialized")\n    \n    async def process(self, message: SystemMessage):\n        """Process execution-related messages"""\n        try:\n            if message.message_type == "plan_generated":\n                # Execute the generated plan\n                plan = message.content\n                await self._execute_plan(plan)\n                return True\n            elif message.message_type == "execute_action":\n                # Execute a single action\n                action = message.content\n                success = await self._execute_action(action)\n                self.system_bus.publish(SystemMessage(\n                    "action_result",\n                    {"action": action, "success": success},\n                    source=self.name\n                ))\n                return success\n            \n            return False\n        except Exception as e:\n            self.report_error(e)\n            return False\n    \n    async def _execute_plan(self, plan: Dict[str, Any]):\n        """Execute a complete plan"""\n        logger.info(f"Executing plan with {len(plan[\'steps\'])} steps")\n        \n        for i, step in enumerate(plan["steps"]):\n            logger.info(f"Executing step {i+1}: {step[\'description\']}")\n            \n            # Check safety before executing each action\n            if not self._is_action_safe(step):\n                logger.error(f"Action {step[\'description\']} is not safe, stopping plan")\n                break\n            \n            success = await self._execute_action(step)\n            \n            if not success:\n                logger.error(f"Action {step[\'description\']} failed, stopping plan")\n                break\n            \n            # Update robot state based on action\n            self._update_robot_state(step)\n            \n            # Publish progress update\n            self.system_bus.publish(SystemMessage(\n                "plan_progress",\n                {"step": i, "total": len(plan["steps"]), "completed": step["description"]},\n                source=self.name\n            ))\n        \n        # Plan completed\n        self.system_bus.publish(SystemMessage(\n            "plan_completed",\n            {"plan": plan["goal"], "success": success},\n            source=self.name\n        ))\n    \n    async def _execute_action(self, action: Dict[str, Any]) -> bool:\n        """Execute a single action"""\n        # Simulate action execution\n        await asyncio.sleep(0.2)  # Simulate action time\n        \n        action_type = action["action"]\n        \n        if action_type == "navigate":\n            if "target" in action:\n                target = action["target"]\n                if isinstance(target, list) and len(target) >= 2:\n                    self.robot_position[0] = target[0]\n                    self.robot_position[1] = target[1]\n                    logger.info(f"Navigated to position: {target}")\n                    return True\n        elif action_type == "move_to":\n            # In simulation, just log\n            logger.info(f"Moved to: {action.get(\'target\', \'unknown\')}")\n            return True\n        elif action_type == "grasp":\n            self.gripper_state = "closed"\n            logger.info("Grasped object")\n            return True\n        elif action_type == "detect":\n            # In simulation, assume detection succeeds\n            logger.info(f"Detected: {action.get(\'target\', \'unknown\')}")\n            return True\n        \n        return False  # Unknown action or failed\n    \n    def _is_action_safe(self, action: Dict[str, Any]) -> bool:\n        """Check if an action is safe to execute"""\n        # In a real system, this would interface with safety manager\n        # For simulation, assume all actions are safe\n        return True\n    \n    def _update_robot_state(self, action: Dict[str, Any]):\n        """Update robot state based on action"""\n        action_type = action["action"]\n        \n        if action_type == "navigate" and "target" in action:\n            target = action["target"]\n            if isinstance(target, list) and len(target) >= 2:\n                self.robot_position[0] = target[0]\n                self.robot_position[1] = target[1]\n        elif action_type == "grasp":\n            self.gripper_state = "closed"\n    \n    def handle_plan_generated(self, message: SystemMessage):\n        """Handle plan generation"""\n        if message.message_type == "plan_generated":\n            asyncio.create_task(self.process(message))\n    \n    def handle_execute_action(self, message: SystemMessage):\n        """Handle single action execution"""\n        if message.message_type == "execute_action":\n            asyncio.create_task(self.process(message))\n    \n    def stop_execution(self):\n        """Stop current execution"""\n        self.executor_running = False\n\n\nclass SystemMonitor:\n    """Monitors overall system health and performance"""\n    \n    def __init__(self, system_bus: SystemBus):\n        self.system_bus = system_bus\n        self.system_bus.subscribe("component_status", self.handle_component_status)\n        self.system_bus.subscribe("error_report", self.handle_error_report)\n        self.system_bus.subscribe("performance_metrics", self.handle_performance_metrics)\n        \n        self.component_statuses = {}\n        self.error_log = []\n        self.performance_history = []\n        self.health_score = 100.0\n        self.running = True\n    \n    def handle_component_status(self, message: SystemMessage):\n        """Handle component status updates"""\n        if message.message_type == "component_status":\n            self.component_statuses[message.source] = message.content\n            self._update_overall_health()\n    \n    def handle_error_report(self, message: SystemMessage):\n        """Handle error reports"""\n        if message.message_type == "error_report":\n            self.error_log.append({\n                "timestamp": message.timestamp,\n                "component": message.source,\n                "error": message.content\n            })\n            self._update_overall_health()\n    \n    def handle_performance_metrics(self, message: SystemMessage):\n        """Handle performance metrics"""\n        if message.message_type == "performance_metrics":\n            self.performance_history.append({\n                "timestamp": message.timestamp,\n                "component": message.source,\n                "metrics": message.content\n            })\n    \n    def _update_overall_health(self):\n        """Update overall system health score"""\n        # Calculate health based on component statuses\n        active_components = len([status for status in self.component_statuses.values() \n                                if status in [ComponentStatus.READY, ComponentStatus.PROCESSING]])\n        total_components = len(self.component_statuses)\n        \n        if total_components > 0:\n            component_health = (active_components / total_components) * 100\n        else:\n            component_health = 100\n        \n        # Factor in errors\n        recent_errors = len([e for e in self.error_log if time.time() - e["timestamp"] < 60])  # Last minute\n        error_penalty = min(50, recent_errors * 10)  # Up to 50% penalty\n        \n        self.health_score = max(0, component_health - error_penalty)\n    \n    def get_system_health_report(self) -> Dict[str, Any]:\n        """Get a comprehensive health report"""\n        return {\n            "health_score": self.health_score,\n            "component_statuses": self.component_statuses,\n            "error_count": len(self.error_log),\n            "recent_errors": self.error_log[-5:],  # Last 5 errors\n            "active_components": len([s for s in self.component_statuses.values() \n                                     if s in [ComponentStatus.READY, ComponentStatus.PROCESSING]]),\n            "performance_metrics": self.performance_history[-10:]  # Last 10 metrics\n        }\n\n\nclass AutonomousHumanoidSystem:\n    """Complete autonomous humanoid robot system"""\n    \n    def __init__(self):\n        # Initialize system bus\n        self.system_bus = SystemBus()\n        \n        # Initialize components\n        self.safety_manager = SafetyManager("SafetyManager", self.system_bus)\n        self.voice_component = VoiceProcessingComponent("VoiceProcessor", self.system_bus)\n        self.perception_component = PerceptionComponent("Perception", self.system_bus)\n        self.planning_component = PlanningComponent("Planner", self.system_bus)\n        self.execution_component = ExecutionComponent("Executor", self.system_bus)\n        \n        # Initialize monitor\n        self.monitor = SystemMonitor(self.system_bus)\n        \n        # System state\n        self.running = False\n        self.start_time = 0.0\n        \n        # Component list for initialization\n        self.components = [\n            self.safety_manager,\n            self.voice_component,\n            self.perception_component,\n            self.planning_component,\n            self.execution_component\n        ]\n    \n    async def initialize(self):\n        """Initialize all system components"""\n        logger.info("Initializing autonomous humanoid system...")\n        \n        self.start_time = time.time()\n        \n        # Initialize all components concurrently\n        init_tasks = [comp.initialize() for comp in self.components]\n        results = await asyncio.gather(*init_tasks, return_exceptions=True)\n        \n        # Check initialization results\n        for i, result in enumerate(results):\n            if isinstance(result, Exception):\n                logger.error(f"Component {self.components[i].name} failed to initialize: {result}")\n            else:\n                logger.info(f"Component {self.components[i].name} initialized successfully")\n        \n        # Start the system bus\n        self.system_bus.start()\n        \n        logger.info("Autonomous humanoid system initialized")\n    \n    async def run(self):\n        """Run the system continuously"""\n        logger.info("Starting autonomous humanoid system operation...")\n        self.running = True\n        \n        # Simulate system operation\n        try:\n            while self.running:\n                # Periodically request system updates\n                if time.time() - self.start_time > 5:  # After 5 seconds\n                    # Publish a sample voice command for demonstration\n                    self.system_bus.publish(SystemMessage(\n                        "voice_input",\n                        b"simulated_audio_data",  # In real system, this would be actual audio\n                        source="SimulatedSource"\n                    ))\n                \n                # Publish system status periodically\n                self.system_bus.publish(SystemMessage(\n                    "system_status_request",\n                    {},\n                    source="System"\n                ))\n                \n                await asyncio.sleep(1)  # Update every second\n        \n        except asyncio.CancelledError:\n            logger.info("System operation cancelled")\n        except Exception as e:\n            logger.error(f"System operation error: {e}")\n    \n    def stop(self):\n        """Stop the system"""\n        logger.info("Stopping autonomous humanoid system...")\n        self.running = False\n        \n        # Stop execution component\n        self.execution_component.stop_execution()\n        \n        # Stop system bus\n        self.system_bus.stop()\n        \n        logger.info("Autonomous humanoid system stopped")\n    \n    def get_system_info(self) -> Dict[str, Any]:\n        """Get comprehensive system information"""\n        return {\n            "system_uptime": time.time() - self.start_time if self.start_time > 0 else 0,\n            "running": self.running,\n            "components": {comp.name: comp.get_status().value for comp in self.components},\n            "system_health": self.monitor.get_system_health_report()\n        }\n\n\ndef main():\n    """Example usage of the system architecture"""\n    print("Autonomous Humanoid System Architecture")\n    print("=" * 50)\n    \n    # Create and initialize the system\n    robot_system = AutonomousHumanoidSystem()\n    \n    async def run_system():\n        # Initialize the system\n        await robot_system.initialize()\n        \n        # Run the system for a short time in this example\n        run_task = asyncio.create_task(robot_system.run())\n        \n        # Let it run for 30 seconds then stop\n        await asyncio.sleep(30)\n        \n        # Stop the system\n        robot_system.stop()\n        \n        # Wait for the run task to complete\n        try:\n            await asyncio.wait_for(run_task, timeout=2.0)\n        except asyncio.TimeoutError:\n            logger.warning("Run task did not complete in time, cancelling...")\n            run_task.cancel()\n    \n    try:\n        # Run the system\n        asyncio.run(run_system())\n    except KeyboardInterrupt:\n        print("\\nSystem interrupted by user")\n    \n    # Print final system info\n    system_info = robot_system.get_system_info()\n    print(f"\\nFinal system info:")\n    print(f"  Uptime: {system_info[\'system_uptime\']:.2f}s")\n    print(f"  Running: {system_info[\'running\']}")\n    print(f"  Components: {system_info[\'components\']}")\n    print(f"  Health score: {system_info[\'system_health\'][\'health_score\']}")\n    \n    print("\\nSystem architecture implemented with:")\n    print("- Modular components with well-defined interfaces")\n    print("- Central message bus for communication")\n    print("- Safety-first design with monitoring")\n    print("- Asynchronous processing for real-time performance")\n    print("- Error handling and health monitoring")\n    print("\\nThe system demonstrates proper software architecture")\n    print("principles applied to robotics systems.")\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"simulation-demonstration",children:"Simulation Demonstration"}),"\n",(0,i.jsx)(n.p,{children:"This implementation demonstrates proper system design principles for autonomous robotic systems, featuring modularity, clear interfaces, safety mechanisms, and asynchronous processing. The architecture allows for independent development and testing of individual components while maintaining the ability to work as a unified system. The system can be integrated with ROS 2 and real robotic platforms."}),"\n",(0,i.jsx)(n.h2,{id:"hands-on-lab-system-architecture-implementation",children:"Hands-On Lab: System Architecture Implementation"}),"\n",(0,i.jsx)(n.p,{children:"In this lab, you'll implement and test the complete system architecture:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement the modular component architecture"}),"\n",(0,i.jsx)(n.li,{children:"Create the central message bus for communication"}),"\n",(0,i.jsx)(n.li,{children:"Implement safety monitoring and error handling"}),"\n",(0,i.jsx)(n.li,{children:"Test component integration and communication"}),"\n",(0,i.jsx)(n.li,{children:"Evaluate system performance and reliability"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"required-equipment",children:"Required Equipment:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ROS 2 Humble environment"}),"\n",(0,i.jsx)(n.li,{children:"Python development environment"}),"\n",(0,i.jsx)(n.li,{children:"(Optional) Robot simulation environment"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"instructions",children:"Instructions:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Create a new ROS 2 package: ",(0,i.jsx)(n.code,{children:"ros2 pkg create --build-type ament_python system_architecture_lab"})]}),"\n",(0,i.jsx)(n.li,{children:"Implement the SystemComponent base class and message bus"}),"\n",(0,i.jsx)(n.li,{children:"Create individual components (SafetyManager, VoiceProcessor, etc.)"}),"\n",(0,i.jsx)(n.li,{children:"Implement the main system orchestrator"}),"\n",(0,i.jsx)(n.li,{children:"Test component communication and message passing"}),"\n",(0,i.jsx)(n.li,{children:"Add monitoring and health reporting features"}),"\n",(0,i.jsx)(n.li,{children:"Implement error handling and recovery procedures"}),"\n",(0,i.jsx)(n.li,{children:"Document your system architecture decisions"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-pitfalls--debugging-notes",children:"Common Pitfalls & Debugging Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tight Coupling"}),": Ensure components remain independent and loosely coupled"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Floods"}),": Implement proper message rate limiting and buffering"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Race Conditions"}),": Use proper synchronization mechanisms for shared resources"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deadlocks"}),": Avoid circular dependencies between components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Leaks"}),": Properly manage resources and message queues"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialization Order"}),": Components may depend on others being ready first"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Bottlenecks"}),": Monitor system performance to identify bottlenecks"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary--key-terms",children:"Summary & Key Terms"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Terms:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"System Architecture"}),": High-level structure of the robotic system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Modular Design"}),": Breaking system into independent, replaceable components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Bus"}),": Central communication mechanism between components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Component Interface"}),": Well-defined inputs and outputs for modules"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety-First Design"}),": Prioritizing safety in all system decisions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decoupled Architecture"}),": Components independent of each other"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"System Health Monitoring"}),": Continuous assessment of system status"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"further-reading--citations",children:"Further Reading & Citations"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:'Shaw, M., & Garlan, D. (1996). "Software Architecture: Perspectives on an Emerging Discipline." Prentice Hall.'}),"\n",(0,i.jsx)(n.li,{children:'Bass, L., Clements, P., & Kazman, R. (2012). "Software Architecture in Practice" (3rd ed.). Addison-Wesley.'}),"\n",(0,i.jsx)(n.li,{children:'Pahl, C., & Dustdar, S. (2006). "A self-protection approach for business process management systems." International Conference on Business Process Management.'}),"\n",(0,i.jsx)(n.li,{children:'Gamma, E., et al. (1995). "Design Patterns: Elements of Reusable Object-Oriented Software." Addison-Wesley.'}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Explain the benefits of a modular architecture for robotic systems."}),"\n",(0,i.jsx)(n.li,{children:"How does the message bus architecture enable component communication?"}),"\n",(0,i.jsx)(n.li,{children:"What safety measures are built into the system design?"}),"\n",(0,i.jsx)(n.li,{children:"Describe how you would extend this architecture to support multiple robots."}),"\n",(0,i.jsx)(n.li,{children:"What patterns would you use to ensure scalability of the robotic system?"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Previous"}),": ",(0,i.jsx)(n.a,{href:"/Hackthon_SpecKitPlus/docs/capstone/intro",children:"Capstone Project Introduction"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Next"}),": ",(0,i.jsx)(n.a,{href:"/Hackthon_SpecKitPlus/docs/appendices/hardware",children:"Appendices - Hardware Requirements"})]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(6540);const i={},a=t.createContext(i);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);