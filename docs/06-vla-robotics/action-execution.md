# Action Execution Pipeline

The action execution pipeline is the critical component that connects high-level plans generated by language models and reasoning systems to low-level robot controls. This pipeline ensures that abstract commands are translated into precise robotic actions while maintaining safety, handling failures, and adapting to environmental changes. The execution pipeline must be robust, responsive, and capable of real-time operation.

## Learning Outcomes

After completing this section, you should be able to:
- Design action execution pipelines that bridge high-level planning and low-level controls
- Implement safety checks and validation procedures for robotic actions
- Handle action failures and recovery strategies
- Monitor action execution and provide feedback to higher-level systems
- Implement adaptive execution that responds to environmental changes
- Design modular action execution systems that support different robot platforms

## Core Concepts

### Hierarchical Action Execution
The action execution pipeline operates at different levels:
- **Task Level**: High-level goals and sub-goals
- **Motion Planning Level**: Path planning and trajectory generation
- **Control Level**: Low-level motor commands and feedback control
- **Actuator Level**: Direct commands to individual actuators

### Action Representation
Actions in the pipeline can be represented as:
- **Symbolic Actions**: Abstract, high-level descriptions
- **Trajectory Actions**: Sequence of positions over time
- **Force Actions**: Force/torque commands for compliant control
- **Event-Driven Actions**: Actions triggered by sensor events

### Real-Time Constraints
The execution pipeline must operate under:
- **Hard Real-Time**: Safety-critical actions with strict timing requirements
- **Soft Real-Time**: Performance-critical actions with preferred timing
- **Best Effort**: Non-critical actions without strict timing requirements

### Failure Detection and Recovery
The pipeline must include:
- **Anomaly Detection**: Identifying when actions are not proceeding as expected
- **Graceful Degradation**: Continuing operation with reduced functionality
- **Recovery Procedures**: Methods to return to safe states after failures
- **Fallback Mechanisms**: Alternative strategies when primary methods fail

## Equations and Models

### Action Execution State Machine

The action execution process can be modeled as a state machine:

```
States: {INIT, PREPARING, EXECUTING, MONITORING, PAUSED, RECOVERING, COMPLETED, FAILED}
Transitions: 
- INIT → PREPARING: Action validation succeeds
- PREPARING → EXECUTING: Pre-conditions met
- EXECUTING → MONITORING: Motion initiated
- MONITORING → COMPLETED: Success criteria met
- MONITORING → FAILED: Failure criteria met
- MONITORING → PAUSED: Pause requested
- PAUSED → EXECUTING: Resume requested
- FAILED → RECOVERING: Recovery procedure initiated
- RECOVERING → COMPLETED: Recovery successful
- RECOVERING → FAILED: Recovery unsuccessful
```

### Action Execution Feedback Loop

The control loop for action execution:

```
ε(t) = r(t) - y(t)
u(t) = K_p * ε(t) + K_i * ∫ε(t)dt + K_d * dε(t)/dt
```

Where:
- `ε(t)` is the error at time t
- `r(t)` is the reference trajectory
- `y(t)` is the actual robot state
- `u(t)` is the control command
- `K_p`, `K_i`, `K_d` are PID gains

### Safety Constraint Monitoring

Safety checks during execution:

```
C_safe(x, u) ≤ 0
```

Where:
- `C_safe` represents safety constraints
- `x` is the robot state
- `u` is the control input

## Code Example: Action Execution Pipeline

Here's an implementation of a comprehensive action execution pipeline:

```python
import asyncio
import time
from enum import Enum
from dataclasses import dataclass
from typing import List, Dict, Any, Optional, Callable
import threading
import queue
from abc import ABC, abstractmethod
import numpy as np


class ActionStatus(Enum):
    """Status of action execution"""
    PENDING = "pending"
    PREPARING = "preparing"
    EXECUTING = "executing"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class ActionType(Enum):
    """Types of actions in the execution pipeline"""
    NAVIGATE = "navigate"
    GRASP = "grasp"
    PLACE = "place"
    MOVE_TO = "move_to"
    ROTATE = "rotate"
    DETECT = "detect"
    FOLLOW = "follow"
    WAIT = "wait"
    CUSTOM = "custom"


@dataclass
class Action:
    """Represents a robotic action with execution parameters"""
    action_type: ActionType
    target_position: Optional[List[float]] = None
    target_object: Optional[str] = None
    target_location: Optional[str] = None
    parameters: Optional[Dict[str, Any]] = None
    priority: int = 5  # 1-10 priority level
    timeout: float = 30.0  # seconds
    preconditions: Optional[List[str]] = None
    postconditions: Optional[List[str]] = None
    description: Optional[str] = None


@dataclass
class ExecutionResult:
    """Result of action execution"""
    action_id: str
    status: ActionStatus
    start_time: float
    end_time: float
    execution_time: float
    error_message: Optional[str] = None
    feedback_data: Optional[Dict[str, Any]] = None


class RobotControllerInterface(ABC):
    """Abstract interface for robot controllers"""
    
    @abstractmethod
    async def move_to(self, position: List[float], orientation: Optional[List[float]] = None) -> bool:
        """Move robot to specific position"""
        pass
    
    @abstractmethod
    async def grasp(self, object_name: str) -> bool:
        """Grasp an object"""
        pass
    
    @abstractmethod
    async def place(self, location: str) -> bool:
        """Place object at location"""
        pass
    
    @abstractmethod
    async def rotate(self, angle: float) -> bool:
        """Rotate robot"""
        pass
    
    @abstractmethod
    async def detect_object(self, object_name: str) -> Optional[Dict[str, Any]]:
        """Detect and locate an object"""
        pass
    
    @abstractmethod
    async def follow_path(self, path: List[List[float]]) -> bool:
        """Follow a path"""
        pass
    
    @abstractmethod
    async def stop_motion(self) -> bool:
        """Emergency stop"""
        pass
    
    @abstractmethod
    async def get_robot_state(self) -> Dict[str, Any]:
        """Get current robot state"""
        pass


class MockRobotController(RobotControllerInterface):
    """Mock robot controller for demonstration"""
    
    def __init__(self):
        self.robot_position = [0.0, 0.0, 0.0]
        self.gripper_state = "open"  # "open" or "closed"
        self.is_moving = False
        self.last_command_time = 0.0
        self.simulation_speed = 1.0
    
    async def move_to(self, position: List[float], orientation: Optional[List[float]] = None) -> bool:
        """Simulate moving to a position"""
        if self.is_moving:
            return False
        
        self.is_moving = True
        self.last_command_time = time.time()
        
        # Simulate movement
        start_pos = self.robot_position.copy()
        distance = np.linalg.norm(np.array(position) - np.array(start_pos))
        
        # Simulate movement over time
        steps = int(distance * 10)  # 10 steps per meter
        for i in range(steps + 1):
            progress = i / steps
            self.robot_position = [
                start_pos[0] + progress * (position[0] - start_pos[0]),
                start_pos[1] + progress * (position[1] - start_pos[1]),
                start_pos[2] + progress * (position[2] - start_pos[2])
            ]
            await asyncio.sleep(0.1 / self.simulation_speed)  # Simulate time to move
        
        self.robot_position = position.copy()
        self.is_moving = False
        
        return True
    
    async def grasp(self, object_name: str) -> bool:
        """Simulate grasping an object"""
        if self.gripper_state == "closed":
            return False  # Already grasping
        
        self.gripper_state = "closed"
        self.last_command_time = time.time()
        await asyncio.sleep(1.0 / self.simulation_speed)  # Simulate grasp time
        
        return True
    
    async def place(self, location: str) -> bool:
        """Simulate placing an object"""
        if self.gripper_state == "open":
            return False  # Not grasping anything
        
        self.gripper_state = "open"
        self.last_command_time = time.time()
        await asyncio.sleep(1.0 / self.simulation_speed)  # Simulate place time
        
        return True
    
    async def rotate(self, angle: float) -> bool:
        """Simulate rotating robot"""
        self.last_command_time = time.time()
        await asyncio.sleep(0.5 / self.simulation_speed)  # Simulate rotation time
        
        return True
    
    async def detect_object(self, object_name: str) -> Optional[Dict[str, Any]]:
        """Simulate object detection"""
        self.last_command_time = time.time()
        await asyncio.sleep(0.5 / self.simulation_speed)  # Simulate detection time
        
        # Simulate successful detection
        return {
            "name": object_name,
            "position": [np.random.uniform(0.5, 1.5), np.random.uniform(0.5, 1.5), 0.0],
            "confidence": 0.9,
            "detected": True
        }
    
    async def follow_path(self, path: List[List[float]]) -> bool:
        """Simulate following a path"""
        if self.is_moving:
            return False
        
        self.is_moving = True
        self.last_command_time = time.time()
        
        for position in path:
            await self.move_to(position)
            await asyncio.sleep(0.1 / self.simulation_speed)
        
        self.is_moving = False
        return True
    
    async def stop_motion(self) -> bool:
        """Emergency stop"""
        self.is_moving = False
        return True
    
    async def get_robot_state(self) -> Dict[str, Any]:
        """Get current robot state"""
        return {
            "position": self.robot_position,
            "gripper_state": self.gripper_state,
            "is_moving": self.is_moving,
            "last_command_time": self.last_command_time
        }


class SafetyMonitor:
    """Monitors safety constraints during action execution"""
    
    def __init__(self):
        self.safety_constraints = {
            "collision_distance": 0.5,  # meters
            "max_velocity": 1.0,  # m/s
            "max_force": 100.0,  # Newtons
            "joint_limits": [-3.14, 3.14],  # radians
        }
        self.emergency_stop_triggered = False
        self.safety_violations = []
    
    def check_safety(self, robot_state: Dict[str, Any], requested_action: Action) -> bool:
        """Check if action is safe to execute"""
        # In a real implementation, this would check various safety metrics
        # For this example, we'll just return True
        if self.emergency_stop_triggered:
            return False
        
        # Simulate checking safety constraints
        is_safe = True
        
        # Example: check if target is too close to obstacles
        if requested_action.target_position:
            # This is a simplified check
            pass
        
        return is_safe
    
    def trigger_emergency_stop(self):
        """Trigger emergency stop"""
        self.emergency_stop_triggered = True
        print("EMERGENCY STOP TRIGGERED")
    
    def clear_emergency_stop(self):
        """Clear emergency stop"""
        self.emergency_stop_triggered = False
        print("Emergency stop cleared")


class ActionExecutor:
    """Executes individual actions with monitoring and safety"""
    
    def __init__(self, robot_controller: RobotControllerInterface, safety_monitor: SafetyMonitor):
        self.robot_controller = robot_controller
        self.safety_monitor = safety_monitor
        self.current_action = None
        self.action_id_counter = 0
        self.execution_history = []
    
    async def execute_action(self, action: Action) -> ExecutionResult:
        """Execute a single action with monitoring"""
        action_id = f"action_{self.action_id_counter}"
        self.action_id_counter += 1
        
        start_time = time.time()
        result = ExecutionResult(
            action_id=action_id,
            status=ActionStatus.PENDING,
            start_time=start_time,
            end_time=0,
            execution_time=0
        )
        
        try:
            # Check safety
            robot_state = await self.robot_controller.get_robot_state()
            if not self.safety_monitor.check_safety(robot_state, action):
                result.status = ActionStatus.FAILED
                result.error_message = "Safety check failed"
                return result
            
            # Execute based on action type
            success = await self._execute_action_type(action)
            
            if success:
                result.status = ActionStatus.COMPLETED
                result.feedback_data = await self._collect_feedback(action)
            else:
                result.status = ActionStatus.FAILED
                result.error_message = f"Action execution failed for {action.action_type}"
        
        except asyncio.CancelledError:
            result.status = ActionStatus.CANCELLED
            result.error_message = "Action was cancelled"
        except Exception as e:
            result.status = ActionStatus.FAILED
            result.error_message = f"Exception during execution: {str(e)}"
        finally:
            result.end_time = time.time()
            result.execution_time = result.end_time - result.start_time
            self.execution_history.append(result)
        
        return result
    
    async def _execute_action_type(self, action: Action) -> bool:
        """Execute action based on its type"""
        if action.action_type == ActionType.NAVIGATE:
            if action.target_position:
                return await self.robot_controller.move_to(action.target_position)
        elif action.action_type == ActionType.GRASP:
            if action.target_object:
                return await self.robot_controller.grasp(action.target_object)
        elif action.action_type == ActionType.PLACE:
            if action.target_location:
                return await self.robot_controller.place(action.target_location)
        elif action.action_type == ActionType.MOVE_TO:
            if action.target_position:
                return await self.robot_controller.move_to(action.target_position)
        elif action.action_type == ActionType.ROTATE:
            if action.parameters and "angle" in action.parameters:
                return await self.robot_controller.rotate(action.parameters["angle"])
        elif action.action_type == ActionType.DETECT:
            if action.target_object:
                result = await self.robot_controller.detect_object(action.target_object)
                return result is not None and result.get("detected", False)
        elif action.action_type == ActionType.FOLLOW:
            if action.parameters and "path" in action.parameters:
                return await self.robot_controller.follow_path(action.parameters["path"])
        elif action.action_type == ActionType.WAIT:
            wait_time = action.parameters.get("duration", 1.0) if action.parameters else 1.0
            await asyncio.sleep(wait_time)
            return True
        
        return False  # Unknown action type or missing parameters
    
    async def _collect_feedback(self, action: Action) -> Dict[str, Any]:
        """Collect feedback after action execution"""
        robot_state = await self.robot_controller.get_robot_state()
        return {
            "robot_state": robot_state,
            "action_completed": action.action_type.value,
            "timestamp": time.time()
        }


class ExecutionPipeline:
    """Main execution pipeline that manages action execution"""
    
    def __init__(self, robot_controller: RobotControllerInterface):
        self.robot_controller = robot_controller
        self.safety_monitor = SafetyMonitor()
        self.action_executor = ActionExecutor(robot_controller, self.safety_monitor)
        self.action_queue = queue.Queue()
        self.is_running = False
        self.execution_thread = None
        self.current_execution_task = None
        self.cancellation_token = None
    
    def start_pipeline(self):
        """Start the execution pipeline"""
        if self.is_running:
            return
        
        self.is_running = True
        self.execution_thread = threading.Thread(target=self._pipeline_worker)
        self.execution_thread.start()
        print("Execution pipeline started")
    
    def stop_pipeline(self):
        """Stop the execution pipeline"""
        self.is_running = False
        if self.current_execution_task:
            self.current_execution_task.cancel()
        if self.execution_thread:
            self.execution_thread.join()
        print("Execution pipeline stopped")
    
    def _pipeline_worker(self):
        """Worker function for the execution pipeline"""
        while self.is_running:
            try:
                # Check for actions in queue
                if not self.action_queue.empty():
                    action = self.action_queue.get(timeout=0.1)
                    asyncio.run(self._execute_single_action(action))
                else:
                    time.sleep(0.01)  # Small delay to prevent busy waiting
            except queue.Empty:
                continue
            except Exception as e:
                print(f"Pipeline worker error: {e}")
    
    async def _execute_single_action(self, action: Action):
        """Execute a single action asynchronously"""
        if self.current_execution_task:
            # Cancel any currently running action if needed
            self.current_execution_task.cancel()
        
        # Create and run the execution task
        self.current_execution_task = asyncio.create_task(self.action_executor.execute_action(action))
        try:
            result = await self.current_execution_task
            print(f"Action {result.action_id} completed with status: {result.status}")
        except asyncio.CancelledError:
            print("Action execution was cancelled")
    
    def submit_action(self, action: Action) -> str:
        """Submit an action for execution"""
        if not self.is_running:
            raise RuntimeError("Execution pipeline is not running")
        
        self.action_queue.put(action)
        return f"submitted_action_{self.action_executor.action_id_counter}"
    
    def submit_action_sequence(self, actions: List[Action]) -> str:
        """Submit a sequence of actions for execution"""
        sequence_id = f"sequence_{int(time.time())}"
        
        async def execute_sequence():
            for i, action in enumerate(actions):
                print(f"Executing action {i+1}/{len(actions)}: {action.action_type.value}")
                result = await self.action_executor.execute_action(action)
                if result.status != ActionStatus.COMPLETED:
                    print(f"Action sequence failed at step {i+1}")
                    return sequence_id
            print(f"Action sequence {sequence_id} completed successfully")
            return sequence_id
        
        # In a real implementation, this would run the sequence task
        # For this example, we'll add each action to the queue
        for action in actions:
            self.submit_action(action)
        
        return sequence_id
    
    def get_status(self) -> Dict[str, Any]:
        """Get current status of the execution pipeline"""
        return {
            "is_running": self.is_running,
            "queue_size": self.action_queue.qsize(),
            "executed_actions": len(self.action_executor.execution_history),
            "safety_monitor_status": {
                "emergency_stop": self.safety_monitor.emergency_stop_triggered,
                "violations_count": len(self.safety_monitor.safety_violations)
            }
        }


def main():
    """Example usage of the action execution pipeline"""
    print("Action Execution Pipeline Example")
    
    # Initialize the robot controller and execution pipeline
    robot_controller = MockRobotController()
    execution_pipeline = ExecutionPipeline(robot_controller)
    
    # Start the pipeline
    execution_pipeline.start_pipeline()
    
    # Create test actions
    test_actions = [
        Action(
            action_type=ActionType.MOVE_TO,
            target_position=[1.0, 0.0, 0.0],
            description="Move to position 1"
        ),
        Action(
            action_type=ActionType.GRASP,
            target_object="red_cup",
            description="Grasp the red cup"
        ),
        Action(
            action_type=ActionType.MOVE_TO,
            target_position=[0.0, 1.0, 0.0],
            description="Move to position 2"
        ),
        Action(
            action_type=ActionType.PLACE,
            target_location="table",
            description="Place object on table"
        )
    ]
    
    print(f"Submitting {len(test_actions)} test actions...")
    
    # Submit actions to pipeline
    action_ids = []
    for i, action in enumerate(test_actions):
        action_id = execution_pipeline.submit_action(action)
        action_ids.append(action_id)
        print(f"Submitted action {i+1}: {action_id}")
        time.sleep(0.5)  # Add small delay between submissions
    
    # Wait a bit for execution
    time.sleep(8)
    
    # Submit a sequence of actions
    sequence_actions = [
        Action(
            action_type=ActionType.ROTATE,
            parameters={"angle": 1.57},  # 90 degrees
            description="Rotate 90 degrees"
        ),
        Action(
            action_type=ActionType.DETECT,
            target_object="box",
            description="Detect box"
        )
    ]
    
    print("\nSubmitting action sequence...")
    sequence_id = execution_pipeline.submit_action_sequence(sequence_actions)
    print(f"Submitted sequence: {sequence_id}")
    
    # Wait for sequence execution
    time.sleep(5)
    
    # Get pipeline status
    status = execution_pipeline.get_status()
    print(f"\nPipeline status: {status}")
    
    # Stop the pipeline
    execution_pipeline.stop_pipeline()
    
    print("\nAction execution pipeline example completed")


if __name__ == "__main__":
    main()
```

## Simulation Demonstration

This implementation demonstrates a comprehensive action execution pipeline that bridges high-level plans to low-level robot controls. The system includes safety monitoring, failure handling, and real-time execution capabilities. The code can be integrated with ROS 2 and simulation environments to create robust robotic action execution systems.

## Hands-On Lab: Action Execution Pipeline Implementation

In this lab, you'll implement and test a complete action execution pipeline:

1. Implement the action execution pipeline with safety monitoring
2. Create action representations and execution handlers
3. Test with different action types and sequences
4. Implement failure detection and recovery procedures
5. Evaluate pipeline performance and safety

### Required Equipment:
- ROS 2 Humble environment
- Robot simulation environment (e.g., Gazebo, Isaac Sim)
- Python development environment
- (Optional) Physical robot for testing

### Instructions:
1. Create a new ROS 2 package: `ros2 pkg create --build-type ament_python action_execution_pipeline`
2. Implement the ActionExecutor and ExecutionPipeline classes
3. Create action representations for different robot capabilities
4. Implement safety monitoring and emergency stop procedures
5. Test with various action sequences in simulation
6. Add failure injection to test recovery mechanisms
7. Evaluate performance metrics (latency, success rate, etc.)
8. Document the system's capabilities and limitations

## Common Pitfalls & Debugging Notes

- **Race Conditions**: Multiple threads accessing shared resources without proper synchronization
- **Timeout Handling**: Actions that don't complete within expected timeframes
- **State Synchronization**: Ensuring the execution system has accurate robot state
- **Safety Checks**: Missing or insufficient safety validations
- **Resource Management**: Proper cleanup of resources during execution
- **Error Propagation**: Errors in one action affecting subsequent actions
- **Timing Constraints**: Missing real-time deadlines for critical actions

## Summary & Key Terms

**Key Terms:**
- **Action Execution Pipeline**: System connecting high-level plans to low-level controls
- **Action Representation**: Formal description of robotic actions
- **Safety Monitor**: System checking for safety constraints during execution
- **Failure Recovery**: Procedures to handle and recover from action failures
- **Real-Time Execution**: Meeting timing constraints for robotic actions
- **Action Sequencing**: Executing multiple actions in proper order
- **State Feedback**: Monitoring robot state during action execution

## Further Reading & Citations

1. Fox, D., et al. (1997). "The dynamic window approach to collision avoidance." IEEE Robotics & Automation Magazine.
2. Khatib, O. (1986). "Real-time obstacle avoidance for manipulators and mobile robots." International Journal of Robotics Research.
3. Siciliano, B., & Khatib, O. (Eds.). (2016). "Springer Handbook of Robotics." Springer.
4. Alami, R., et al. (2006). "A tightly integrated execution system for mobile manipulation tasks." IEEE/RSJ International Conference on Intelligent Robots and Systems.

## Assessment Questions

1. Explain the role of the action execution pipeline in connecting high-level planning to low-level controls.
2. What are the key safety considerations in action execution for robotics?
3. Describe the state machine model for action execution and its states.
4. How can failure detection and recovery be implemented in action execution pipelines?
5. What real-time constraints must be considered when designing action execution systems?

---
**Previous**: [LLM-Based Planning for Robotics](./llm-planning.md)  
**Next**: [Introduction to Humanoid Robotics](../../07-capstone/intro.md)